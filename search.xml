<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[零基础学高数017：不定积分003]]></title>
    <url>%2F2019%2F04%2F21%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0017%EF%BC%9A%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86003%2F</url>
    <content type="text"><![CDATA[1.有理函数的积分（数三不考） 2.简单无理函数的积分 3.,三角有理式的积分]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江南大学之行]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B1%9F%E5%8D%97%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[2019.4.3：出发3月末，得知清明节与广西特有节日“三月三”相连，再加上我三月三前一天一整天没课，所有，4月初将迎来一个6天长假。经过一番思考，决定趁着这假期去江苏无锡，看看自己考研的心仪学校——江南大学。4月3日中午两点，我们一行三人（好友欣和她的舍友昊）踏上了离校的出租车。由于桂林—无锡的车票有点小贵，于是我们决定先从桂林→杭州，再从杭州出发去往江苏（欣的考研学校在南京，昊并不考研，这次是去男友家玩，于是我们三人在杭州便分开了）。桂林—杭州要硬座要坐大约16个小时，杭州—无锡要坐大约三个半小小时，可能是假期的放松与愉悦，我们三人并未觉得太过漫长。 2019.4.4：抵达在历经近20个小时的硬座旅途之后，我到达了无锡。一下车也看见了实现打好招呼来接我的在无锡读书的同学键。旅途的疲惫让我没有了剩余的精力立马去往江南大学或者去景点游玩，于是就跟着同学去了他的学校参观。到达之后发现无锡的气温与桂林相差无几，但桂林时常阴雨闷热，无锡这几天阳光明媚。忘了说明，同学键也有考研的意图，并且也打算报考江南大学，在他的校园里，跟着他逛了一圈，感觉虽然比我的学校大上不少，但却少了一份诗意与秀气，毕竟桂林是全国著名的旅游城市，在山山水水方面还是优于大多数城市。随后我们在操场叙旧谈心，说了很多无关痛痒的话题，也聊了一些自己对考研的看法。之后，离开了他的学校，他带我到了附近的一条小吃街游玩，由于我真的身体疲惫，状态不佳，随便逛逛之后我们便找了一家饭馆解决了晚饭，再之后他便回到了他的学校，而我便乘地铁前往我所预订的江南大学附近的宾馆住处。 下了地铁，骑着小蓝车去往宾馆，我看着路旁的建筑与夜景，无锡这座城市与桂林相比，交通更显宽阔，当时街上行人亦所剩无几，我听着歌，吹着风，顿时感觉无比的惬意，心里想起的居然是高三那年自己也是这样在晚自习之后骑着车回家，如今三年过去，自己的变化真的挺大的，以前自己还是家人眼里的乖乖孩，整天重复这上学、做题、回家、做题，虽然当时基本上保持着学习的状态，但其实自己并不知道自己为什么学习，只知道家长老师灌输的努力学习，考上好大学，但根本不知道自己想要什么，自己该做什么，对自己的未来也没有什么憧憬与规划，如今，高考失败导致我现在决定考研，但与当时相比较，自己成长了很多，不管是外观还是内在，体验了许许多多之前二十年都没有接触过的事物，遇到了许许多多形形色色的人，更重要的是，开始明白自己想要的是什么，也开始对自己的未来有了时不时的憧憬与规划…… 带着这些思绪和一天的舟车劳顿，我在宾馆的床上沉沉地睡去…… 2019.4.5：参观第二天一早（其实也九点多了），我背着书包先去吃了顿早餐，打算然后去江南大学参观，不得不说无锡的灌汤小笼包真的好好吃，这让我在无锡呆了多少天就吃了多少顿小笼包。 吃过早餐，由于同学键打算下午过来找我，于是我便打算上午先自己逛江大。之前在网上查阅江南大学的信息时，便记住了那座极具特色的牌坊校门，于是我便舍弃了离我很近的江大南门，而直冲北门而去（结果骑了整整半个小时），到了北门之后，映入眼帘的便是那座雄伟的牌坊： 我当时的心情很复杂，既有终于见到实物的兴奋与喜悦，也夹杂着自己能否考上这座学府的担心与忧虑。怀揣着这种情绪，我缓缓走进了自己的心仪之所。 北门进去貌似是学生的公寓，看着许多男男女女在路上背着书包、骑着单车，有的神采奕奕地独自行走着，有的和好友一起说笑着边走边聊， 随后，我独自漫步在江南大学的各个角落，由于正值清明假期，所以校园里的人不多，显得格外静谧。 最后，在逛了一上午之后，我终于来到了这栋楼。 站在这栋楼下，思绪万千，自己报考的专业——软件工程就在这座学院里，自己考研成功，便是其中的一员…由于看见进出的人需要刷卡才能进入，于是打消了进入内部参观的念头，我绕着这座楼走了两三遍，多么希望，多么希望自己来年能够以一名江南大学数字媒体学院软件工程研究生的身份昂首挺胸的进入这栋楼。 我坐在这栋楼外部的楼梯上，看着它，想了很多，之前一直对自己报考什么学校摇摆不定，我感觉从现在开始，我不会再动摇了。 2019.4.6：离开在最后离开无锡之前，我再次来到了江南大学，再次在数字媒体学院这栋楼周围走了两圈。 江南大学！来年再会！ 最后，希望自己这一年能尽自己最大努力，不要胸有大志，而又碌碌无为！]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>江南大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向循环链表：字母表实现前后移动]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%AD%97%E6%AF%8D%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[问题描述要求实现用户输入一个数使得26个字母的排列发生变化，例如用户输入3，输出结果： DEFGHIJKLMNOPQRSTUVWXYZABC 同时需要支持负数，例如用户输入-3，输出结果： XYZABCDEFGHIJKLMNOPQRSTUVW 代码：实现位置的前后都能移动且数据都是连着的，当然数据结构选择双向循环链表啦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define OK 1#define ERROR 0 typedef char ElemType;typedef int status; /*定义双向链表，前驱和后继*/typedef struct DualNode&#123; ElemType data; struct DualNode *prior; struct DualNode *next;&#125;DualNode,*DuLinkList; /*链表初始化*/status InitList(DuLinkList *L)&#123; DualNode *p,*q; int i; (*L) = (DuLinkList)malloc(sizeof(DualNode)); if (!(*L)) &#123; return ERROR; &#125; (*L)-&gt;next = (*L)-&gt;prior = NULL; p = (*L);//头结点 for (i = 0; i &lt; 26; i++)//p,q交替，实现初始化 &#123; q = (DualNode *)malloc(sizeof(DualNode)); if (!q) &#123; return ERROR; &#125; q-&gt;data = 'A'+i; q-&gt;prior = p; q-&gt;next = p-&gt;next; p-&gt;next = q; p = q; &#125; p-&gt;next = (*L)-&gt;next; (*L)-&gt;next-&gt;prior = p; return 0; &#125; void Caesar(DuLinkList *L,int i)&#123; if(i&gt;0) &#123; while(i&gt;0)&#123; (*L)=(*L)-&gt;next; i--; &#125; &#125; if(i&lt;0) &#123; while(i&gt;0)&#123; (*L)=(*L)-&gt;next; i++; &#125; &#125;&#125; int main()&#123; DuLinkList L; int i,n; InitList(&amp;L); printf("请输入一个整数："); scanf("%d", &amp;n); printf("\n"); Caesar(&amp;L, n); for (i = 0; i &lt; 26; i++) &#123; L = L-&gt;next; printf("%c", L-&gt;data); &#125; printf("\n"); return 0;&#125; 一、结构体的创建 在C语言中，实现数据结构的一种常用方法便是使用结构体（structure）其示例代码如下： 12345&gt; struct stu &#123;&gt; int num;&gt; char ch;&gt; &#125;;&gt; struct表示创建结构体 stu为结构体名称，里面的内容是各种变量类型（可以嵌套struct），然后使用示例如下： 1234&gt; struct stu s;&gt; scanf("%d", &amp;s.num);&gt; printf("%d\n", s.num);&gt; 第一行表示创建结构为stu的结构体s，此后访问结构体内的内容需要使用 名称.名称，比如说里面的s.num表示访问结构体s里面的num。为了方便，我们介绍typedef关键词。 二、typedef的用法 typedef的作用相当于给变量类型起别名，举个例子，long long 太长，每次都写long long很烦，我们可以简化成这样 12345&gt; typedef long long ll;&gt; ll b;&gt; scanf("%lld", &amp;b);&gt; printf("%lld\n", b);&gt; 那么，对于结构体我们可以这样使用 12345678&gt; typedef struct &#123;&gt; int num;&gt; char ch;&gt; &#125; stu;&gt; stu s;&gt; scanf("%d", &amp;s.num);&gt; printf("%d\n", s.num);&gt; 这样子就可以直接用stu来创建结构体 而不需要用struct stu s;这么长一串了。 【注】:C语言给结构体定义别名用typedef关键字操作，就两种情况： 给结构体起一个别名，如： typedef struct ABC{ … }S; ——这就为结构体ABC定义了一个别名S。以后写S x;就等价于写struct ABC x;了。 给结构体指针起一个别名，如： typedef struct ABC{ … }*PS; ——这就为结构体指针ABC *定义了一个别名PS。以后写PS pt;就等价于写struct ABC pt;了。注意这里是用typedef给struct ABC{…} *起一个别名PS，而不是给struct ABC{…}起一个别名PS——后者是说不通的，起码的错误是标识符不可能以*开头！]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：N个人围成一圈，从第一个人开始报数，报到m的人出圈，剩下的人继续从1开始报数，报到m的人出圈；如此往复，直到所有人出圈。（模拟此过程，输出出圈的人的序号） [问题来历：据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。] 循环单链表实现： C语言： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;node;node *create(int n)&#123; node *current = NULL, *head,*newNode; int i = 1; head = (node*)malloc(sizeof (node )); current = head; if( 0 != n ) &#123; while( i &lt;= n ) &#123; newNode = (node *)malloc(sizeof (node)); newNode-&gt;data = i++; // 为循环链表初始化，第一个结点为1，第二个结点为2。 current-&gt;next = newNode; current = current-&gt;next; &#125; current-&gt;next = head-&gt;next;//让最后一个结点指向第一个结点（第一个结点指真正有值的第一个结点，并不是头结点，头结点并不含值） &#125; free(head); return current-&gt;next ;&#125;int main()&#123; node *create(int n); int n=41,m=3,i; node *temp;//中间变量 node *p=create(n);//既是第一个结点，也是哨兵 while(p!=p-&gt;next)&#123; for(i=1;i&lt;m-1;i++)&#123; p=p-&gt;next; &#125; printf("%d\n",p-&gt;next-&gt;data); temp=p-&gt;next; p-&gt;next=temp-&gt;next; free(temp); p=p-&gt;next; &#125; printf("%d\n",p-&gt;next-&gt;data); return 0;&#125; Java代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class node &#123; int data; node next; node(int x) &#123; data = x; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; int n = 41, m = 3, i; node p = create(n);// 既是第一个结点，也是哨兵 node temp;// 中间变量 m%=n; while (p != p.next) &#123; for (i = 1; i &lt; m - 1; i++) &#123; p = p.next; &#125; System.out.println(p.next.data); temp = p.next; p.next = temp.next; p = p.next; &#125; System.out.println(p.next.data); &#125; private static node create(int n) &#123;// 初始化循环单链表 node current = null, head = new node(0); current = head;// 哨兵p int i = 1; if (0 != n) &#123; while (i &lt;= n) &#123; node newNode = new node(i++); current.next = newNode; current = current.next; &#125; current.next = head.next;// 令尾结点指向第一个结点（注意：是第一个结点，并非头结点） &#125; return current.next; &#125;&#125; malloc和free是C语言中申请内存空间与释放内存空间的函数。 关于 head = (node*)malloc(sizeof (node )); 的解释 sizeof (node ) 就是求 struct node 这个结构体占用的字节数。 malloc(sizeof (node )) 申请 struct node 这个结构体占用字节数大小的空间 (node*)malloc(sizeof (node )) 将申请的空间的地址强制转化为 struct node * 指针类型 head = (node*)malloc(sizeof (node )) 将那个强制转化的地址赋值给 head.]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数016：不定积分002]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0016%EF%BC%9A%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86002%2F</url>
    <content type="text"><![CDATA[第一类换元法（凑微分法） 第二类换元法（常用于去根号） 第三类分步积分法(考频最高) 例题练习：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录and注册面板小练习]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%99%BB%E5%BD%95%E9%9D%A2%E6%9D%BF%E5%B0%8F%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[效果如图所示 登录代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;LoginForm&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; background: url(https://ww1.sinaimg.cn/large/007i4MEmly1g1ijjymj69j32yo1o07wh.jpg) no-repeat; background-size: cover; &#125; #LoginForm &#123; width: 300px; height: 300px; background: #000000b8; margin: auto; margin-top: 180px; border-top: 4px solid #70d5f5c7; padding: 30px; &#125; #LoginForm h6 &#123; margin: 0; color: white; font-size: 22px; text-align: center; height: 45px; border-bottom: 1px solid; margin-bottom: 30px; &#125; .nameAndPass &#123; width: 100%; color: white; border: 1px solid #61b0c9; background: #011d1d; font-size: 14px; font-weight: bold; padding: 14px 10px; margin-bottom: 10px; margin-left: -10px; &#125; #loginButt &#123; border: none; font-family: arial; margin: 0; width: 100%; background: #61b0c9; height: 40px; color: white; font-size: 16px; font-weight: bold; margin-top: 12px; margin-bottom: 35px; &#125; #LoginForm a &#123; padding: 10px; text-decoration: none; font-size: 13px; font-family: 微软雅黑; color: white; &#125; #LoginForm a:hover &#123; text-decoration: underline; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="LoginForm"&gt; &lt;h6&gt;LoginForm&lt;/h6&gt; &lt;!--placeholder 属性提供可描述输入字段预期值的提示信息（hint）。该提示会在输入字段为空时显示，并会在字段获得焦点时消失。--&gt; &lt;input class="nameAndPass" type="text" placeholder="UserName" name="UserName" value="" /&gt; &lt;input class="nameAndPass" type="password" placeholder="PassWord" name="PassWord" value="" /&gt; &lt;input id="loginButt" type="button" value="登录" /&gt; &lt;center&gt; &lt;a href="#"&gt;尚未注册&lt;/a&gt; &lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;br /&gt; &lt;a href="#"&gt;回到首页&lt;/a&gt; &lt;/center&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 注册代码： html: 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;注册面板小练习&lt;/title&gt; &lt;link rel="stylesheet" href="css/Register.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="RegisterForm"&gt; &lt;h6&gt;RegisterForm&lt;/h6&gt; &lt;form action="" method="post"&gt; &lt;!--placeholder 属性提供可描述输入字段预期值的提示信息（hint）。该提示会在输入字段为空时显示，并会在字段获得焦点时消失。--&gt; &lt;input class="nameAndPassAndEmail" type="text" placeholder="UserName" name="UserName" value="" /&gt; &lt;input class="nameAndPassAndEmail" type="text" placeholder="Email" name="Email" value="" /&gt; &lt;input class="nameAndPassAndEmail" type="password" placeholder="PassWord" name="PassWord" value="" /&gt; &lt;p&gt;I agree to&lt;a href="#" id="terms"&gt;terms and conditions.&lt;/a&gt;&lt;/p&gt; &lt;input id="registerButt" type="button" value="注册" /&gt; &lt;center&gt; &lt;a href="#"&gt;已有账号&lt;/a&gt; &lt;a href="#"&gt;回到首页&lt;/a&gt; &lt;/center&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Register.css: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475body &#123; margin: 0; padding: 0; background: url(https://ww1.sinaimg.cn/large/007i4MEmly1g1ijjymj69j32yo1o07wh.jpg) no-repeat; background-size: cover;&#125;#RegisterForm &#123; width: 300px; height: 320px; background: #000000b8; margin: auto; margin-top: 180px; border-top: 4px solid #70d5f5c7; padding: 30px;&#125;#RegisterForm h6 &#123; margin: 0; color: white; font-size: 22px; text-align: center; height: 45px; border-bottom: 1px solid; margin-bottom: 20px;&#125;.nameAndPassAndEmail &#123; width: 100%; color: white; border: 1px solid #61b0c9; background: #011d1d; font-size: 14px; font-weight: bold; padding: 14px 10px; margin-bottom: 10px; margin-left: -10px;&#125;#RegisterForm p &#123; float: left; color: white; font-size: 14px; margin: 0 15px 0 0;&#125;#terms &#123; color: white; font-size: 14px;&#125;#registerButt &#123; border: none; font-family: arial; margin: 0; width: 100%; background: #61b0c9; height: 40px; color: white; font-size: 16px; font-weight: bold; margin-top: 12px; margin-bottom: 10px;&#125;#RegisterForm a &#123; color: white; font-size: 14px; padding: 10px; text-decoration: none;&#125;#RegisterForm a:hover &#123; text-decoration: underline;&#125;]]></content>
      <categories>
        <category>前端工程师</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中常量、常变量、符号常量的区别]]></title>
    <url>%2F2019%2F03%2F26%2FC%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%B8%E9%87%8F%E3%80%81%E5%B8%B8%E5%8F%98%E9%87%8F%E3%80%81%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[常量普通常量在程序运行过程中，其值不能被改变的量称为常量，如整型常量：1,2,3…;实型常量:123.456 , 0.345 , -1.2 , 0.0…;字符常量：如’a’ , ‘Z’ ,’\n’ ,’\t’… 符号常量用#define指令，指定一个符号名称代表一个常量，如：#define PI 3.1416 (注意行末没有分号) 常变量如:const int a=3; 表示a被定义为一个整型变量，指定其值为3，并且在变量存在期间其值不能被改变。 常变量与常量的异同：常变量具有变量的基本属性：有类型，占存储单元，只是不允许改变其值，可以说，常变量是有名字的不变量，而常量是没有名字的不变量。 常变量与符号常量的不同： #define PI 3.1415926 const flost pi=3.1415926;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中，&&与&，||与|的区别]]></title>
    <url>%2F2019%2F03%2F20%2FJava%E4%B8%AD%EF%BC%8C%26%26%E4%B8%8E%26%EF%BC%8C%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在Java的逻辑运算符中，有这么四类：&amp;&amp;（短路与），&amp;，|，||（短路或）。 &amp;&amp;和&amp;都是表示与，区别是&amp;&amp;只要第一个条件不满足，后面条件就不再判断。而&amp;要对所有的条件都进行判断。看下面的程序： public static void main(String[] args) {​ // TODO Auto-generated method stub​ if((23!=23)&amp;&amp;(100/0==0)){​ System.out.println(“运算没有问题。”);​ }else{​ System.out.println(“没有报错”);​ }​ } 输出的是“没有报错”。而将&amp;&amp;改为&amp;就会如下错误：Exception in thread “main” java.lang.ArithmeticException: / by zero 原因是：&amp;&amp;时判断第一个条件为false，后面的100/0==0这个条件就没有进行判断。​ &amp;时要对所有的条件进行判断，所以会对后面的条件进行判断，所以会报错。 ||和|都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断。看下面的程序： public static void main(String[] args) {​ // TODO Auto-generated method stub​ if((23==23)||(100/0==0)){​ System.out.println(“运算没有问题。”);​ }else{​ System.out.println(“没有报错”);​ }​ } 此时输出“运算没有问题”。若将||改为|则会报错。 原因是：||判断第一个条件为true，后面的条件就没有进行判断就执行了括号中的代码，而|要对所有的条件进行判断， 所以会报错。原文：https://blog.csdn.net/lishiyuzuji/article/details/8116516 第六届蓝桥杯JavaB组题目1： java中提供了对正则表达式的支持。有的时候，恰当地使用正则，可以让我们的工作事半功倍！ 如下代码用来检验一个四则运算式中数据项的数目，请填写划线部分缺少的代码。 注意：只填写缺少代码，不要写任何多余内容，例如，已有的双引号。 public class A{​ public static int f(String s)​ {​ return s.split(“____“).length;​ }public static void main(String[] args){​ System.out.println(f(“12+355-218/9-3”)); //7​ System.out.println(f(“35412+3-14/76”)); //6} } 答案： \\+|\\-|\\*|\\/ 我的答案： \\D 输出结果均为： 7 6]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之DOM基础]]></title>
    <url>%2F2019%2F03%2F19%2FJavaScript%E4%B8%AD%E7%9A%84DOM%2F</url>
    <content type="text"><![CDATA[什么是DOM1.理解DOM： DOM（Document Object Model ，文档对象模型）一种独立于语言，用于操作xml，html文档的应用编程接口。 怎么说，我从两个角度理解： 对于JavaScript，为了能够使JavaScript操作Html，JavaScript就有了一套自己的dom编程接口。 对于Html，dom使得html形成一棵dom树，类似于一颗家族树一样，一层接一层，子子孙孙。 所以说，有了DOM，在我看来就是相当于JavaScript拿到了钥匙一样可以去操作Html的每一个节点，触摸Html每寸肌肤。（咳。。。） 2.介绍Html的DOM树：说明：html标签通过浏览器的解析后才会形成dom树，此后HTML中的每个标签元素，属性，文本都能看做是一个DOM的节点，JavaScript都能通过dom的提供的编程接口操作到每个节点，去了解浏览器的渲染机制能够帮助我们了解dom。 认识JavaScript中的DOM编程接口上面说了html形成的dom树，接着说下通过js的dom编程接口去操作这棵dom树。 JavaScriptDOM操作的常用方法和属性：: 常用方法： 获取节点： document.getElementById(idName) //通过id号来获取元素，返回一个元素对象 document.getElementsByName(name) //通过name属性获取id号，返回元素对象数组 document.getElementsByClassName(className) //通过class来获取元素，返回元素对象数组（ie8以上才有） document.getElementsByTagName(tagName) //通过标签名获取元素，返回元素对象数组 获取/设置元素的属性值： element.getAttribute(attributeName) //括号传入属性名，返回对应属性的属性值[注意：此方法可获取元素除class属性以外的所有属性，包括HTML自带属性与用户自定义属性，获取class属性通过ele.className获取] element.setAttribute(attributeName,attributeValue) //传入属性名及设置的值 创建节点Node： document.createElement(“h3”) //创建一个html元素，这里以创建h3元素为例 document.createTextNode(String); //创建一个文本节点； document.createAttribute(“class”); //创建一个属性节点，这里以创建class属性为例 增添节点： element.appendChild(Node); //往element内部最后面添加一个节点，参数是节点类型 elelment.insertBefore(newNode,existingNode); //在element内部的中在existingNode前面插入newNode 删除节点： element.removeChild(Node) //删除当前节点下指定的子节点，删除成功返回该被删除的节点，否则返回null 常用属性 获取当前元素的父节点 ： element.parentNode //返回当前元素的父节点对象 获取当前元素的子节点： element.chlidren //返回当前元素所有子元素节点对象，只返回HTML节点 element.chilidNodes //返回当前元素多有子节点，包括文本，HTML，属性节点。（回车也会当做一个节点） element.firstChild //返回当前元素的第一个子节点对象 element.lastChild //返回当前元素的最后一个子节点对象 获取当前元素的同级元素： element.nextSibling //返回当前元素的下一个同级元素 没有就返回null element.previousSibling //返回当前元素上一个同级元素 没有就返回null 获取当前元素的文本： element.innerHTML //返回元素的所有文本，包括html代码[注意：若采用的是ele.innerHTML=”XXX”的形式，则表示设置ele元素开始和结束标签之间的HTML内容为XXX] element.innerText //返回当前元素的自身及子代所有文本值，只是文本内容，不包括html代码 获取当前节点的节点类型：node.nodeType //返回节点的类型,数字形式（1-12）常见几个1：元素节点，2：属性节点，3：文本节点。 设置样式：element.style.color=“#eea”; //设置元素的样式时使用style，这里以设置文字颜色为例，注意styleName不能使用“-”连字符形式而应改为驼峰命名形式，如font-size应该改为fontSize 获取当前元素的clss属性：element.className //返回当前元素的class属性[注意：若采用的是ele.className =”XXX”的形式，则表示设置ele元素的class属性为XXX] 参考：http://www.cnblogs.com/Ry-yuan/p/6918155.html]]></content>
      <categories>
        <category>前端工程师</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质数的判断]]></title>
    <url>%2F2019%2F03%2F19%2F%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[判断一个数是不是质数代码Java代码： 123456789101112131415161718import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner cin=new Scanner(System.in); int n=cin.nextInt(); System.out.println(isPrime(n)); &#125; private static boolean isPrime(int n)&#123; boolean flag=true; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; flag=false; &#125; &#125; return flag; &#125; &#125; C语言代码： 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int isPrime(int); int n,flag; scanf("%d",&amp;n); flag=isPrime(n); if(flag==1) &#123; printf("%d is Prime\n",n); &#125;else &#123; printf("%d is Not Prime\n",n); &#125; &#125;int isPrime(int n)&#123; int flag=1; int i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; flag=-1; &#125; &#125; return flag;&#125; [注]：好久没写过C了，都忘了怎么写了，都忘了C语言中没有布尔型变量…… 讲解[关于i*i&lt;=n的讲解]：要判断n是否为质数，就从2一直尝试到n-1的做法效率是最差的！ 其实只要从2一直尝试到根号n，就可以了。因为因数都是成对出现的。比如，100的因数有：1和100，2和50，4和25，5和20，10和10。看出来没有？成对的因数，其中一个必然小于等于100的开平方，另一个大于等于100的开平方。 输出≤n(n≤10000000)的质数的个数代码Java代码 1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner cin=new Scanner(System.in); int n=cin.nextInt(); System.out.println(fun(n)); &#125; private static int fun(int n)&#123; boolean[] flag=new boolean[n+1]; int count=0,num=2; while(num&lt;=n)&#123; if(flag[num]==false)&#123; for(int i=num*2;i&lt;=n;i+=num)&#123; flag[i]=true; &#125; count++; &#125; num++; &#125; return count; &#125;&#125; 讲解[筛法]：首先，2是公认最小的质数，所以，先把所有2的倍数去掉；然后剩下的那些大于2的数里面，最小的是3，所以3也是质数；然后把所有3的倍数都去掉，剩下的那些大于3的数里面，最小的是5，所以5也是质数……上述过程不断重复，就可以把某个范围内的合数全都除去（就像被筛子筛掉一样），剩下的就是质数了。而筛选这一步骤通过构造一个定长的布尔型容器（通常用数组）来实现，分别表示2~n的标志，若是非质数，则设为true，若是质数，则保持原状态false，最后2~n中标志为false的就全部是质数了 。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的String]]></title>
    <url>%2F2019%2F03%2F17%2FJavaScript%E4%B8%AD%E7%9A%84String%2F</url>
    <content type="text"><![CDATA[String的基本方法 charAt(index):返回字符串中index位置的字符 charCodeAt(index):返回字符串中index位置的字符的编码 indexOf(char)：从头检索返回字符char在字符串中首次出现的位置，char也可以是子字符串，若没有则返回-1 lastIndexOf(cgar)：从尾部检索返回字符char在字符串中最后一次出现的位置，char也可以是子字符串，若没有则返回-1 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str="ifyoucansayHELLOJS"; var index1=str.lastIndexOf("O");//15 var index2=str.lastIndexOf("HELLO");//11(即子串“HELLO”的首字符H的位置) console.log(index1); console.log(index2); &lt;/script&gt; &lt;/body&gt; 输出结果： 字符串的截取方法1.slice()语法：stringObject.slice(start,end) 功能：截取子字符串 参数说明：①start:必需，指定子字符串的开始位置②end:可选，表示子字符串到哪里结束，end本身不在截取范围之内，省略时截取至字符串的末尾③当参数为负数时，会将传入的负值与字符串的长度相加 返回值：截取的子字符串 [注]：和数组的slice()方法没什么区别 2.substring()[说明]:语法功能同slice()完全一样 [区别]: 当参数为负数时，自动将参数转换为0 substring()会自动将较小的数作为开始位置，将较大的数作为结束位置 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str="123456789"; console.log(str.slice(-5,7));//相当于(4,7) console.log(str.substring(-5,7));//相当于(0,7) console.log(str.substring(-4,-7));//相当于(0,0),不截取，返回空字符串 console.log(str.substring(2,-3));//substring()会自动将较小的数作为开始位置，将较大的数作为结束位置 &lt;/script&gt; &lt;/body&gt; 输出结果： 3.substr()语法：stringObject.slice(start,length) 功能：截取子字符串 参数说明：①start:必需，指定子字符串的开始位置②length:可选，表示截取的字符总数，省略时截取至字符串的末尾③当参数为负数时，会将传入的负值与字符串的长度相加④当length为负数时，返回空字符串 返回值：截取的子字符串 String的其他两个方法1.split()语法：stringObject.split(separator) 功能：把一个字符串分割成字符串数组 参数说明：separator–必需，分隔符 返回值：数组 2.replace()语法：stringObject.split(regexp/substr,replacement) 功能：replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 参数说明：①regexp:必需，规定子字符串或要替换的模式的RegExp对象②replacement:必需。一个字符串值。规定了替换文本或生成替换文本的函数。 返回值：String 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var str = "123-456-789"; var newStr1 = str.replace(/-/, ','); var newStr2 = str.replace(/-/g, ','); console.log(newStr1); console.log(newStr2); &lt;/script&gt; &lt;/body&gt; 输出结果： 3.toUpperCase()语法：stringObject.toUpperCase() 功能：把字符串转为大写 4.toLowerCase()语法：stringObject.toLowerCase() 功能：把字符串转为小写 [小练习]:将”border-left-color”变成驼峰命名”borderLeftColor” 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function fun(str) &#123; var arr = str.split('-'), newStr = arr[0]; for(var i = 1, len = arr.length; i &lt; len; i++) &#123; var word = arr[i]; newStr += word.charAt(0).toUpperCase() + word.substr(1); &#125; &#125; fun("border-left-color"); &lt;/script&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>前端工程师</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数015：不定积分001]]></title>
    <url>%2F2019%2F03%2F17%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0015%EF%BC%9A%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[一.不定积分的概念、性质及存在性1.原函数与不定积分的概念2.原函数存在定理 ①连续函数必有原函数；(但非连续函数不一定没有原函数) ②含有第一类间断点或无穷间断点的函数，在包含该间断点在内的任何区间内都没有原函数. 关于定理②的证明: 3.不定积分的性质 4.基本积分公式（需熟稔于心）]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速找到未知长度单链表的中间结点]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%9C%AA%E7%9F%A5%E9%95%BF%E5%BA%A6%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[腾讯面试题快速找到未知长度单链表的中间结点 一般思路 先遍历链表，获得链表的长度L 然后再次从头开始遍历，循环L/2次找到中间结点 时间复杂度：O(L+L/2) 1234567891011121314151617181920212223242526272829303132333435class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode curNode = new ListNode(0); ListNode node = curNode; for (int i = 1; i &lt;= 10; i++) &#123; ListNode newNode = new ListNode(i); curNode.next = newNode; curNode = curNode.next; &#125; System.out.println(fingMidNode(node)); &#125; private static int fingMidNode(ListNode node) &#123; int length=0; ListNode curNode=node; while(curNode!=null) &#123; length++; curNode=curNode.next; &#125; for(int i=0;i&lt;length/2;i++) &#123; node=node.next; &#125; return node.val; &#125;&#125; 输出结果：5 改进思路 利用快慢指针的原理：设置两个指针search和mid 一开始search和mid都指向单链表的头结点 search的移动速度是mid的两倍，即search每次移动2个结点，mid每次移动1个结点 当search指向末尾结点的时候，mid正好就指向了中间结点 算法复杂度：O(L/2) 123456789101112131415161718192021222324252627282930313233343536class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode curNode = new ListNode(0); ListNode node = curNode; for (int i = 1; i &lt;= 10; i++) &#123; ListNode newNode = new ListNode(i); curNode.next = newNode; curNode = curNode.next; &#125; System.out.println(fingMidNode(node)); &#125; public static int fingMidNode(ListNode n) &#123; ListNode search, mid; search = n; mid = n; while (search.next != null) &#123; if (search.next.next != null) &#123; search = search.next.next; mid = mid.next; &#125; else &#123; search = search.next; &#125; &#125; return mid.val; &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的数组]]></title>
    <url>%2F2019%2F03%2F16%2FJavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[【注】：JavaScript中的数组与其他常见编程语言中的数组有所区别，它可以自动扩容，可以存储任意类型的数据元素，更像是Java’中的List集合。** 创建数组： 1.var a=new Array() &lt;括号内可以指定数组的容量大小，也可以不指定&gt; ２.var a=[ele1,ele2,…eleX] 数组的栈方法：1.push()语法：arrayObject.push(newele1,newele2,…,newX) 功能：把括号内的参数顺序添加到数组arrayObject的尾部 返回值：参数添加完成后数组的新长度 2.unshift()语法：arrayObject.unshift(newele1,newele2,…,newX) 功能：把括号内的参数添加到数组arrayObject的尾部开头 返回值：参数添加完成后数组的新长度 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = [797, "slashyouth", true]; var newLen = a.unshift("hello", 1997); console.log(newLen); console.log(a); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： 3.pop()语法：arrayObject.pop() 功能：删除数组arrayObject的最后一个元素 返回值：被删除的那个元素 4.shift()语法：arrayObject.shift() 功能：删除数组arrayObject的第一个元素 返回值：被删除的那个元素 数组的转换方法1.join()语法：arrayObject.join(separator) separator：分隔符 功能：用于把数组中的所有元素放入一个字符串(就是将数组转为字符串) 返回值：字符串 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = [797, "slashyouth", true]; var str1 = a.join(); //不含参数，默认分隔符为逗号 console.log(str1); var str2 = a.join("-"); console.log(str2); var str3 = a.join(""); console.log(str3); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： 2.reverse()语法：arrayObject.reverse() 功能：用于颠倒数组中元素的顺序 返回值：反序后的数组 3.sort()语法：arrayObject.sort(sortby) 功能：用于对数组中的元素进行排序 返回值：排序后的数组 说明： 1.即使数组中的每一项都是数值，sort()方法仍会将元素先转为字符串，再对转换后的字符串进行比较并排序 2.sort()方法可以接收一个比较函数作为参数 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = [12,5,8,10,2]; var num1=a.sort(); console.log(num1);//输出结果是[10, 12, 2, 5, 8]，并非[2, 5, 8, 10, 12]，因为会先转为字符串进行比较：先比较高位，高位相同再比较低位 var num2=a.sort(function (a,b)&#123;return a-b;&#125;);//降序 console.log(num2); var num3=a.sort(function (a,b)&#123;return b-a;&#125;);//升序 console.log(num3); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： 4.concat()语法：arrayObject.concat(array1,array2,…arrayX) 功能：用于连接两个或多个数组 返回值：连接后的新数组 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a1 = [12,5,8,10,2]; var a2=["a","b","c"]; var a3=[true,false]; var newArray=a1.concat(a2,a3); console.log(newArray); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： 5.slice()语法：arrayObject.slice(start,end) 功能：从已有数组中返回选定的数组 返回值：数组 start（必需）：规定从何处开始选取，如果是负数，从数组尾部开始算起 end（可选）：规定从何处结束选取，是数组片断结束处的数组下标 [注]：arrayObject.slice(start,end)→[start,end)左闭右开 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var color = ["red", "orange", "yellow", "green", "blue", "white", "pink", "balck"]; var newColor = color.slice(2, 5); //左闭右开，选取下标为2、3、4的元素，新数组为：["yellow","green","blue"] console.log(newColor); var newArr = color.slice(-3, 7);//start为负数：从数组尾部开始算起；若start&lt;0,也可用数组长度length-start替换start，效果一样 console.log(newArr); &lt;/script&gt; &lt;/body&gt; 输出结果： 强大的splice()方法1.使用splice()方法删除数组项语法：arrayObject.splice(index,count) 功能：删除从index处开始的零个或多个元素 返回值：含有被删除的元素的数组 说明：index为从哪个下标开始删除；count表示删除多少个元素，若count设为0，则不会删除项目，若不设置count，则删除从index-末尾的所有元素 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var color = ["red", "orange", "yellow", "green", "blue", "white", "pink", "balck"]; var arr = color.splice(2, 2); //删除掉color数组中的"yellow", "green" console.log(color); console.log(arr); &lt;/script&gt; &lt;/body&gt; 输出结果： 2.使用splice()方法插入数组项语法：arrayObject.splice(index,0,item1,item2…itemX) 功能：再指定位置插入值 返回值：空数组 index:要从哪个位置开始插入 0:要删除的项数 item1…itemX:要插入的项 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var color = ["red", "orange", "yellow", "green", "blue", "white", "pink", "balck"]; var arr = color.splice(2, 0,"HELLO","JAVASCRIPT"); console.log(color); console.log(arr); &lt;/script&gt; &lt;/body&gt; 输出结果： 3.使用splice()方法替换数组项语法：arrayObject.splice(index,count,item1,item2…itemX) 功能：在指定位置插入值，且同时删除任意数量的项 返回值：从原始数组删除的项，若没有删除任何项则返回空数组 index:起始位置 0:要删除的项数 item1…itemX:要插入的项 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var color = ["red", "orange", "yellow", "green", "blue", "white", "pink", "balck"]; var arr = color.splice(2, 2,"AAAAAAAAAAAA","BBBBBBBBBBB","CCCCCCCCCCCCC"); console.log(color); console.log(arr); &lt;/script&gt; &lt;/body&gt; 输出结果：]]></content>
      <categories>
        <category>前端工程师</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数014：曲率渐近线]]></title>
    <url>%2F2019%2F03%2F16%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0014%EF%BC%9A%E6%9B%B2%E7%8E%87%E6%B8%90%E8%BF%91%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[这一节数一数二考查较多，尤其是数二 曲率及曲率半径（数三不考） 渐近线例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的逻辑操作符]]></title>
    <url>%2F2019%2F03%2F15%2FJavaScript%E7%9A%84%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[逻辑操作符： &amp;&amp;:与 ||：或 !：非 &amp;&amp;:只要有一个条件不成立，返回false123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var num1 = 10, num2 = 20, num3 = 30, str = "welcome", bool = false, n = null, m; console.log(num1 &lt; num2 &amp;&amp; num2 &lt; num3); console.log(num1 &lt; num2 &amp;&amp; num2 == num3); console.log(num2 &lt; num3 &amp;&amp; num3 &gt; num1 &amp;&amp; bool); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： 说明：&amp;&amp;不仅能操作布尔值，还能操作任意一种类型的数据,在有一个操作数不是布尔值的情况，&amp;&amp;操作就不一定返回值，此时它遵循下列规则： 如果第一个操作数隐式类型转换后为true，则返回第二个操作数 如果第一个操作数隐式类型转换后为false，则返回第一个操作数 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var num1 = 10, num2 = 20, num3 = 30, str = "welcome", bool = false, n = null, m; console.log(str &amp;&amp; num3); //str隐式转型后为true，则返回num3的值，即30 console.log("hello" &amp;&amp; num1 &amp;&amp; "result"); //"hello"与num1隐式转型之后都为true，返回后一位的值，即"result" //以下 若第一个操作数隐式转型后为false（0与""隐式转型都为false），则返回第一个操作数 console.log(0 &amp;&amp; str); console.log("" &amp;&amp; str); console.log(0 &amp;&amp; "" &amp;&amp; str); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： 注：操作符中只需出现一个nul，则返回结果必为null 操作符中只需出现一个NaN，则返回结果必为NaN 操作符中只需出现一个undefined，则返回结果必为undefined 操作符中若同时出现null、NaN、undefined中的多个，则返回三者最先出现的 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var num1 = 10, num2 = 20, num3 = 30, str = "welcome", bool = false, n = null, m; console.log((1-str)&amp;&amp; num1); console.log(n&amp;&amp; str); console.log(m&amp;&amp; num1&lt;num2); console.log(null&amp;&amp;NAN&amp;&amp;str); console.log(m&amp;&amp;null&amp;&amp;NAN); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果： ||:只要有一个条件成立，返回true说明：||不仅能操作布尔值，还能操作任意一种类型的数据,在有一个操作数不是布尔值的情况，&amp;&amp;操作就不一定返回值，此时它遵循下列规则： 如果两个操作数都是null，则返回null 如果两个操作数都是NaN，则返回NaN 如果两个操作数都是undefined,则返回undefined 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var m; console.log(123 || 0);//123为true，直接返回123，不继续往后进行判读 console.log("hello" || "");//"hello"为true，直接返回"hello"，不继续往后进行判读 console.log("" || "hello");//""为false，继续往后判读，"hello"为true，返回"hello" console.log((1 - "hello") || "" || "JavaScript");//(1 - "hello") 和 ""都为false，继续判断，返回"JavaScript" //||：一直往下判断，若判断到某个操作数为true，则返回该操作数的值，若判断到最后一个操作数仍为false或null或NaN或undefined，那么则返回false或null或NaN或undefined console.log(m || NaN || null); console.log(null || m || NaN); console.log(NaN || null || m); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 輸出結果： ||总结：一直往下判断，若判断到某个操作数为true，则返回该操作数的值，若判断到最后一个操作数仍为false或null或NaN或undefined，那么则返回false或null或NaN或undefined !:说明： 无论操作数是什么数据类型，逻辑非都会返回一个布尔值 !!同时使用两个逻辑非时：&lt;相当于负负得正的意思&gt; 第一个逻辑非操作会基于无论操作数是什么数据类型，都会返回一个布尔值 第二个逻辑非则对上一步所得布尔值取反 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; console.log(!false); console.log(!9); console.log(!"hello"); console.log(!""); console.log(!NaN); console.log(!null); console.log(!!true); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 输出结果：]]></content>
      <categories>
        <category>前端工程师</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数013：函数的单调性与曲线的凹凸性]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0013%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%87%B9%E5%87%B8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.函数单调性的判别法则(要会证明)2.曲线凹凸性的定义及判定(判定：要会证明)曲线凹凸性的另一种定义： 3.极值点及拐点的定义及判定(必要条件+充分条件：要会证明)极值点: 拐点:(必要条件+充分条件：要会证明) 如何记忆： 求函数极 值的步骤(求曲线拐点的步骤类似，只需把用到的导数抬高一阶):求函数最值的步骤： 注： 4.例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add Two Numbers (链表)]]></title>
    <url>%2F2019%2F03%2F14%2FAdd-Two-Numbers-(%E9%93%BE%E8%A1%A8)%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路： 题目翻译： 您将获得两个非空链表，表示两个非负整数。数字以相反的顺序存储，每个节点包含一个数字。添加两个数字并将其作为链接列表返回。 您可以假设这两个数字不包含任何前导零，除了数字0本身。 初步思路： 【借鉴】：阶乘计算 三个链表：已知的l1与l2，以及存储结果的新链表l3 每次将l1的当前结点node1与l2的当前结点node2进行相加运算; 若计算结果位数为1，当然可以直接添加进链表3；但如果计算结果位数&gt;1怎么办呢？ 每次两结点的计算结果要么为1位，要么为2位，当位数=2时，可以写成A=a*10+r(r为A%10，a=A/10); 链表的每个结点的数据实际上=实际结果%10+上一结点相加产生的进位 不在赘述，图形化可能更能任意理解 我的初步代码： 123456789101112131415161718192021222324252627class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public class Solution&#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int r=0;//每次的进位 ListNode curNode=new ListNode(0); ListNode l3=curNode; while(l1!=null||l2!=null)&#123; if(l1==null)&#123; l1=new ListNode(0); &#125; if(l2==null)&#123; l2=new ListNode(0); &#125; int result=(l1.val+l2.val)+r; curNode.next=new ListNode(result%10); curNode=curNode.next; r=result/10; l1=l1.next; l2=l2.next; &#125; return l3.next;//舍弃头结点 &#125;&#125; Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 对于 (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)得到了正确结果，但仍然报：Wrong Answer 因为若Input: (5) + (5 )，应该得到0-&gt;1，但上述代码Output:0 因为当最后一对结点node1与node2计算若产生进位，仍然是只把计算result%10存入了链表3，而忽略了此时产生的进位，因此将上述代码改进： 1234567891011121314151617181920212223242526272829303132class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public class Solution&#123; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int r=0; ListNode curNode=new ListNode(0); ListNode l3=curNode; while(true)&#123; if(l1==null&amp;&amp;l2!=null)&#123; l1=new ListNode(0); &#125; if(l2==null&amp;&amp;l1!=null)&#123; l2=new ListNode(0); &#125; if(l1==null&amp;&amp;l2==null)&#123; if(r!=0) curNode.next=new ListNode(r); break; &#125; int result=(l1.val+l2.val)+r; curNode.next=new ListNode(result%10); curNode=curNode.next; r=result/10; l1=l1.next; l2=l2.next; &#125; return l3.next; &#125;&#125; 成功：Accepted 官方所给答案： 1234567891011121314151617181920212223242526class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public class Solution&#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125;&#125; 思路与我的基本一致，但细节上略有不同，比我的代码简洁许多，自己还是不够完善，继续学习！！！ 【题目来源】：LeetCode]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2019%2F03%2F13%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; &#125; public int pop() &#123; &#125;&#125; 思路： 栈为先进后出，队列为先进先出。 题目要求我们用两个栈实现先进先出： 选定栈1为进栈口，选定栈2为出栈口 整体思路是元素先依次进入栈1，再从栈1依次弹出到栈2，然后弹出栈2顶部的元素，整个过程就是一个队列的先进先出。 但是在交换元素的时候需要判断两个栈的元素情况：“进队列时”，队列中是否还有元素，若有，说明栈2中的元素不为空，此时就先将栈2的元素倒回到栈1 中，保持在“进队列状态”。“出队列时”，将栈1的元素全部弹到栈2中，保持在“出队列状态”。 所以要做的判断是，进时，栈2是否为空，不为空，则栈2元素倒回到栈1，出时，将栈1元素全部弹到栈2中，直到栈1为空。 1234567891011121314151617181920import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; while(!stack2.empty())&#123; stack1.push(stack2.pop()); &#125; stack1.push(node); &#125; public int pop() &#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125;&#125; 大神代码： 12345678910111213141516171819202122import java.util.Stack; public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack1.empty()&amp;&amp;stack2.empty())&#123; throw new RuntimeException("Queue is empty!"); &#125; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 public class ListNode {​ int val;​ ListNode next = null; ListNode(int val) {​ this.val = val; }} import java.util.ArrayList;public class Solution {​ public ArrayList printListFromTailToHead(ListNode listNode) {​ return null;​ }} 思路这道题看起来比较简单，我一开始认为直接按顺序遍历每个结点，并存入集合list，当结点为空时表示所有结点已经遍历结束，最后通过Collections.reverse(list)方法反转list中元素顺序即可。 1234567891011121314151617181920212223 class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;import java.util.ArrayList;import java.util.Collections;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(listNode != null)&#123; list.add(listNode.val); listNode = listNode.next; &#125; Collections.reverse(list);//使用Collections的reverse方法，直接将list反转 return list; &#125;&#125; 结果通过，但通过浏览他人代码发现：为什么还要调用reverse呢，添加的时候直接头插法就行了啊. 数据结构单链表创建之头插法+尾插法：https://blog.csdn.net/ZXC641483573/article/details/78079732 头插法代码： 1234567891011121314151617181920 class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(listNode != null)&#123; list.add(0,listNode.val); listNode = listNode.next; &#125; return list; &#125;&#125; 注释：以前常用的都是List的add(参数)方法，基本没用过public void add(int index,E element)方法，而且刚开始看上述头插法代码以为循环中每次list.add(0,listNode.val);都会把之前list(0)的值覆盖，通过查阅API发现： 纠正了一直以来的错误认知。 除此之外，还可借助堆栈的“后进先出”实现： 1234567891011121314151617181920212223242526 class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125;import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); while(listNode!=null)&#123; stack.push(listNode.val); listNode=listNode.next; &#125; ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); while(!stack.isEmpty())&#123; list.add(stack.pop()); &#125; return list; &#125;&#125; 参考思路：https://www.nowcoder.com/questionTerminal/d0267f7f55b3412ba93bd35cfa8e8035 众多解法中有很多采用递归求解，实质上也是利用了堆栈结构实现。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路丑数：只包含质因子2、3、5的数称作丑数。（说通俗点：一个数的所有因子中，为质数的因子只能是2、3、5） 关键点（难点）：丑数p = 2 ^ x * 3 ^ y * 5 ^ z； 即每个丑数都满足上述式子，只是x、y、z取值不同生成了不同的丑数， 同时得出一个丑数p1一定是由另一个小于它的丑数p2乘以2 or 乘以3 or 乘以5得到的。 如： 1是最小（也是最初的丑数），于是我们分别将1与2、3、5相乘→得到2、3、5三个丑数； 然后由2、3、5出发我们又会得到：4，6,10,6，9,15,10,15,25九个丑数； …… 但是这样得到的丑数是有重复且无序的，题目要求我们求按从小到大的顺序的第N个丑数，即要求我们得出的丑数是有序排列的（升序）。 那么： 先定义一个队列a用来存储丑数，a[0]=1; 当由1得出2、3、5三个丑数时，我们可以取新生成的丑数中最小的丑数:2，然后2加入队列a，即a={1,2}; 紧接着我们由a[1]=2与2、3、5相乘得出新丑数：4、6、10，注意：此时4并不是当前的最小丑数，不要忘了第二部生成的3和5，因此，我们可以维护3个数列； 假设有3个数列，分别为： 乘以2产生的丑数队列、 乘以3产生的丑数队列、 乘以5产生的丑数队列； （1）丑数数组： 1 *乘以2的队列：2 *乘以3的队列：3 *乘以5的队列：5 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （2）丑数数组：1,2 ​ *乘以2的队列：4 ​ *乘以3的队列：3，6 ​ *乘以5的队列：5，10 ​ 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （3）丑数数组：1,2,3 ​ *乘以2的队列：4,6 ​ *乘以3的队列：6,9 ​ *乘以5的队列：5,10,15 ​ 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （4）丑数数组：1,2,3,4 ​ *乘以2的队列：6，8 ​ *乘以3的队列：6,9,12 ​ *乘以5的队列：5,10,15,20 ​ 选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （5）丑数数组：1,2,3,4,5 ​ *乘以2的队列：6,8,10， ​ *乘以3的队列：6,9,12,15 ​ *乘以5的队列：10,15,20,25 ​ 选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列； ​ …………………… ​ 疑问： ​ 1.为什么分三个队列？ ​ 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的； ​ 2.为什么比较三个队列头部最小的数放入丑数数组？ ​ 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。 ​ 实现思路： ​ 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组； ​ （1）1 ​ |2 ​ |3 ​ |5 ​ 目前指针指向0,0,0，队列头arr[0] * 2 = 2, arr[0] 3 = 3, arr[0] 5 = 5 ​ （2）1 2 ​ 2 |4 ​ |3 6 ​ |5 10 ​ 目前指针指向1,0,0，队列头arr[1] * 2 = 4, arr[0] 3 = 3, arr[0] 5 = 5 ​ （3）1 2 3 ​ 2| 4 6 ​ 3|6 9 ​ |5 10 15 目前指针指向1,1,0，队列头arr[1] * 2 = 4, arr[1] 3 = 6, arr[0] 5 = 5 ……………… 代码：123456789101112131415161718192021222324252627282930313233343536import java.util.List;import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int N=in.nextInt(); int num=GetUglyNumber_Solution(N); System.out.println(num); &#125; public static int GetUglyNumber_Solution(int N) &#123; if(N&lt;=0) return 0; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); list.add(1); int i1=0,i2=0,i3=0;//3个记录指针 while(list.size()&lt;N) &#123; int n1=list.get(i1)*2; int n2=list.get(i2)*3; int n3=list.get(i3)*5; int min=Math.min(n1, Math.min(n2, n3)); list.add(min); if(min==n1) &#123; i1++; &#125; if(min==n2) &#123; i2++; &#125; if(min==n3) &#123; i3++; &#125; &#125; return list.get(N-1); &#125;&#125; 运行时间：26ms 占用内存：9468k 参考思路：https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数012：泰勒公式]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0012%EF%BC%9A%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.定理(1主要用于求极限；2主要用于证明。此处重点掌握第一种) 2.需要背诵的公式！！！ 3.两种题型 例题： 总结：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人的运动范围]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ public class Solution {​ public int movingCount(int threshold, int rows, int cols)​ { ​ } } 思路题中所给代码movingCount(int threshold, int rows, int cols)方法参数含义： int threshold：行坐标和列坐标的数位之和不能&gt;threshold int rows, int cols：矩形的行列数 首次进入方格矩形，横纵坐标：（0，0） 对所进方格进行判断： ①x和y是否正确； ②当前格子的flag是true还是false(true表示走过)； ③当前格子的行坐标和列坐标的数位之和与threshold进行大小比较； 若上述三点任一点不满足，则返回0。 若符合条件，则将该方格标记为true,表示已经走过 对该方格左右上下四个方向的相邻格子进行递归判断； 将四个方向遍历的返回结果进行相加，再加上1（一开始进入(0,0)坐标），即为机器人能够达到格子数。 我的代码： 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class Solution &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int rows = in.nextInt(); int cols = in.nextInt(); int threshold = in.nextInt(); System.out.println(movingCount(threshold, rows, cols)); &#125; public static int movingCount(int threshold, int rows, int cols) &#123; boolean[][] flag = new boolean[rows][cols];// 记录是否走过:false表示未走过 return find(0, 0, rows, cols, threshold, flag); &#125; private static int find(int x, int y, int rows, int cols, int k, boolean[][] flag) &#123; if (x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || flag[x][y] || getSum(x) + getSum(y) &gt; k) return 0; flag[x][y] = true; return find(x - 1, y, rows, cols, k, flag) + find(x + 1, y, rows, cols, k, flag) + find(x, y - 1, rows, cols, k, flag) + find(x, y + 1, rows, cols, k, flag)+1; &#125; private static int getSum(int number) &#123; int sum = 0; while (number &gt; 0) &#123; sum += number % 10; number /= 10; &#125; return sum; &#125;&#125; 【相似题目】：矩阵中的路径 更多巧妙解法 更多解法中还有许多自己目前难以理解的解法思路，希望自己能经常观看，早日理解！！！]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数011：洛必达法则]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0011%EF%BC%9A%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[定理： [注]：运用洛必达法则，必须同时满足上述三个条件，缺一不可！！！解题过程中常常看到满足（1）就直接运用洛必达法则，这种情况很有可能因并未满足（2）（3）而落入陷阱。 【例子】： 这道题一定要搞懂！！！ 例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结绳]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%BB%93%E7%BB%B3%2F</url>
    <content type="text"><![CDATA[思路： 绳子每进行一次连接就要对折一次，长度就会减少一半，那么应该让较长的绳子尽量少对折。按照这样的想法，那么应该将绳子从小到大排列，两两进行串连。 所以每次选取最小得绳子和第二小得绳子进行对折即可。 代码v1.0: 12345678910111213141516171819202122232425262728import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int N = in.nextInt(); for (int i = 0; i &lt; N; i++) &#123; list.add(in.nextInt()); &#125; int max = f(list); System.out.println(max); &#125; private static int f(List&lt;Integer&gt; list) &#123; if (list.size() == 1) &#123; return list.get(0); &#125; Collections.sort(list); list.add((list.get(1) + list.get(0)) / 2); List&lt;Integer&gt; list2 = list.subList(2, list.size()); return f(list2); &#125;&#125; 思考：首先对绳子的长度进行排序，取最短的两根绳子a、b，对折，对折后的长度一定不会超过这两根绳子的最大长度，所有不需要担心打乱顺序。只需要一次排序就行。 代码v2.0: 1234567891011121314151617181920import java.util.ArrayList;import java.util.Collections;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int N = in.nextInt(); for (int i = 0; i &lt; N; i++) &#123; list.add(in.nextInt()); &#125; Collections.sort(list); int result=list.get(0); for(int i=1;i&lt;list.size();i++) &#123; result=(result+list.get(i))/2; &#125; System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数010：微分中值定理]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0010%EF%BC%9A%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.罗尔定理 !!! 2.拉格朗日中值定理(很重要！！！) 3.柯西中值定理 注：（要明白课本上3个定理的证明过程）]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方格计数]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%96%B9%E6%A0%BC%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第九届蓝桥杯题2： 标题：方格计数 如图所示，在二维平面上有无数个1x1的小方格。 我们以某个小方格的一个顶点为圆心画一个半径为1000的圆。 你能计算出这个圆里有多少个完整的小方格吗？ 注意：需要提交的是一个整数，不要填写任何多余内容。 思路1： 将圆以圆心为原点作横纵坐标轴，分成四个象限，圆中完整小方格的数目=第一象限圆内完整方格数*4； 对第一象限圆内的坐标点进行遍历，圆内某点p1(x,y)，p1左边相邻点p2(x-1,y)，p1上边相邻点p3(x,y+1)， 若p1、p2、p3三点同时在圆内→这三点所确定的小方格在圆内 Java代码： 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; int count = 0; for (int i = 1; i &lt;= 1000; i++) &#123; for (int j = 0; j &lt;= 1000; j++) &#123; if (f(i, j)) &#123; count++; &#125; &#125; &#125; System.out.println(count * 4);//注意要乘4:4个象限 &#125; private static boolean f(int x, int y) &#123; if (x * x + y * y &lt;= 1000 * 1000 &amp;&amp; (x - 1) * (x - 1) + y * y &lt;= 1000 * 1000 &amp;&amp; x * x + (y + 1) * (y + 1) &lt;= 1000 * 1000) &#123; return true; &#125; return false; &#125;&#125; 输出结果：3137548 思路2： 只看第一象限，a点 从x轴从右往左遍历，b从a点出发，往上走，直到刚要走出圆，这时候 原点与a，a与b，形成一个矩形，count+=矩形面积（即为该矩形包含方格个数），然后a继续走，b继续走，又形成一个矩形，但这次b，就要减去上次b的y坐标； Java代码： 1234567891011121314public class Main0102 &#123; public static void main(String[] args) &#123; int a,b=0,preB=b,count=0; for(a=1000;a&gt;=0;a--) &#123; while(a*a+b*b&lt;=1000*1000) &#123; b++; &#125; b--; count+=a*(b-preB);//preB为上一次b点的值 preB=b; &#125; System.out.println(count*4); &#125;&#125; 输出结果：3137548]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数009：导数与微分的计算]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0009%EF%BC%9A%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[1.基本求导公式： 2.四则运算法则： 复合函数的求导法则 3.反函数的求导法则：反函数定义： 反函数求导法则: 画图证明： 4.幂指函数求导法则： 5.隐函数求导法则： 6.参数方程求导法则： 7.高阶导数求导法则： [注]：前两条与求一阶导公式一致，但第三条与求一阶导有所不同。 常见的几个函数的n阶导： 例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶乘计算]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%98%B6%E4%B9%98%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[问题描述 输入一个正整数n，输出n!的值。 其中n!=123…**n。 算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 输入包含一个正整数n，n&lt;=1000。 输出格式 输出n!的准确值。 样例输入 10 样例输出 3628800 由于n的值可能很大，所以一般不能简单地运用暴力枚举的方法进行解题。但若采用Java进行解题，则Java中的BigInteger类型则可以承受住n的取值过大的问题，代码如下： 1234567891011121314import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n=in.nextInt(); BigInteger result=BigInteger.ONE; for(int i=n;i&gt;0;i--) &#123; result=result.multiply(BigInteger.valueOf(i)); &#125; System.out.println(result); &#125;&#125; 运行结果： 103628800 但其他常见语言如C、C++并不具备类似于Java中BigInteger这样的数据类型，因此有如下解法。 采用递归解题： 12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n=in.nextInt(); System.out.println(f(n)); &#125; private static int f(int n) &#123; if(n==1) &#123;return 1;&#125; return n*f(n-1); &#125;&#125; 运行结果： 103628800 但当n继续增大到一定程度时，递归算法仍无法算出结果。 利用数组： 1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n=in.nextInt(); int [] result=new int[1000*100]; result[0]=1; int num,r; for(int i=2;i&lt;=n;i++) &#123; r=0; for(int j=0;j&lt;result.length;j++) &#123; num=result[j]*i+r;//当前阶乘所得到的结果num result[j]=num%10;//当前result[j]中该存放的应是临时结果num的低位对应数值 r=num/10;//当前临时结果num的高位对应数值 &#125; &#125; int index=0; for(int i=result.length-1;i&gt;=0;i--) &#123; if(result[i]!=0) &#123;//反向遍历数组找到首次≠0的元素，即为最终阶乘结果的最高位数值 index=i;//记录下阶乘结果最高位数值的下标index break; &#125; &#125; for(int i=index;i&gt;=0;i--) &#123;//反向遍历result[index]~result[0]即为最后结果 System.out.print(result[i]); &#125; &#125;&#125; 理解难点： for(int j=0;j&lt;result.length;j++) {​ num=result[j]*i+r;//当前阶乘所得到的结果num​ result[j]=num%10;//当前result[j]中该存放的应是临时结果num的低位对应数值​ r=num/10;//当前临时结果num的高位对应数值​ } 重点理解：num=result[j]*i+r; 【注】：将阶乘过程中的每次乘的结果的个位、十位、百位…反向存在数组中，考虑进位！进位！进位！当某一次乘的数为n时，则代表乘到了最后。 拓展训练： 代码： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String sa = sc.next(); String sb = sc.next(); int[] a = new int[100]; int[] b = new int[100]; int[] c = new int[101]; int count = 0; for (int i = sa.length() - 1; i &gt;= 0; i--) &#123; a[count++] = Integer.parseInt(sa.substring(i, i + 1)); &#125; count = 0; for (int i = sb.length() - 1; i &gt;= 0; i--) &#123; b[count++] = Integer.parseInt(sb.substring(i, i + 1)); &#125; int r = 0, x=0,y=0; for(int i=0;i&lt;c.length;i++) &#123; if(x&gt;=100||y&gt;=100) &#123; break; &#125; int result = (a[x++] + b[y++])+r; c[i] = result % 10; r = result / 10; &#125; int flag=0; for(int i=c.length-1;i&gt;=0;i--) &#123; if(c[i]!=0) &#123; flag=i; break; &#125; &#125; for (int i = flag; i &gt;= 0; i--) &#123; System.out.print(c[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>阶乘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/S与B/S之争]]></title>
    <url>%2F2019%2F03%2F02%2FCS%E4%B8%8EBS%E4%B9%8B%E4%BA%89%2F</url>
    <content type="text"><![CDATA[C/S架构: 所谓C/S架构，就是客户端/服务端的架构形式。 传统的Web应用程序开发模式，需要同时开发客户端和服务端的程序。由服务端的程序提供基本的服务，客户端是提供给用户的访问接口，用户可以通过客户端的软件访问服务器提供的服务。 在这种架构方式中，多个客户端围绕着一个或多个服务器，这些客户端安装在客户机上，负责用户业务逻辑的处理，在服务器端仅仅对重要的过程和数据库进行处理和存储，每个服务器都分担这服务器的压力，这些客户端可以根据不同的用户的需求来进行定制。 C/S弊端： 在C/S架构中，系统部署的时候需要在每个用户的机器上安装客户端，这样的处理方式带来很大的工作量，而且在C/S架构中，软件的升级也是很麻烦的一件事情，哪怕是再小的一点改动，都得把所有的客户端全部修改更新。这些致命的弱点决定了C/S结构的命运。在C/S架构模式流行一段时间以后，逐渐被另一种Web应用系统的架构方式所代替。这种新的Web软件架构的模式就是B/S。 B/S架构： 所谓B/S架构，就是浏览器/服务器的架构形式。 在B/S架构的开发模式中，客户端就是简单的浏览器程序，可以通过HTTP协议访问服务器端的应用，在服务端，与通信相关的处理都由服务器软件负责，这些服务器软件都是由第三方的软件厂商提供。开发人员只需要把功能代码部署在Web服务器中，客户端就可以通过浏览器访问到这些功能代码，从而实现向客户提供的服务。B/S架构就是浏览器/服务器的架构形式。 在这种架构方式中，采取了基于浏览器的策略，简化了客户端的开发工作。在B/S架构的客户机中，不用安装客户端软件，只要有通用的浏览器工具，就可以访问服务器端提供的服务。在各种操作系统中，都提供了浏览器工具，这些浏览器工具都是遵循着相同的协议规范，所以B/S结构的客户端在各种系统环境中都已经实现。而且，在浏览器访问服务器的过程中，使用的是HTTP协议，所以这种方式非常容易就可以穿过防火墙的限制。而且在B/S结构的服务器端，也不用处理通信相关的问题。这些问题都由Web服务器提供，Web服务器处理用户的HTTP请求，开发人员只需要专注开发业务逻辑功能即可。总之，Web服务器完成了底层的操作，给应用软件的开发提供了基础的通信服务，从而减轻了开发人员重复开发通信相关的功能，从而提高了开发的效率，降低了B/S结构应用程序开发的难度。 B/S缺点： B/S架构也有自身的一些缺点，例如界面元素单调。在B/S结构的程序中，失去了桌面应用程序丰富的用户界面，程序在交互性上没有C/S架构那么人性化。 在C/S和B/S两种架构之间，并没有严格的界限，两种架构没有好坏之分，使用这两种架构都可以实现系统的功能。开发人员可以根据实际的需要进行选择。例如需要丰富的用户体验，那就选择C/S架构。在目前的网络游戏中，基本都是选择C/S架构。如果更偏重的是功能服务方面的实现，就需要选择B/S架构，这也正是目前绝大部分管理应用系统采用的软件架构方法。]]></content>
      <categories>
        <category>JavaWeb学习</category>
      </categories>
      <tags>
        <tag>C/S与B/S</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数008：导数与微分的定义]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0008%EF%BC%9A%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[1.导数的定义 2.导数的几何意义 3.微分的定义 4.微分的几何意义 5.连续、可导、可微的关系 例题例题1： 拓展训练: 例题2： 例题3： 例题4： 例题5： 由例题5可得出以下结论：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数007：极限的应用03]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0007%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A803%2F</url>
    <content type="text"><![CDATA[1.有界性与最大值最小值定理 2.介值定理 3.零点定理 例题：]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定方程求解]]></title>
    <url>%2F2019%2F02%2F28%2F%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[【题目描述】给定正整数a，b，c。求不定方程 ax+by=c 关于未知数x和y的所有非负整数解组数。 【输入】一行，包含三个正整数a，b，c，两个整数之间用单个空格隔开。每个数均不大于1000。 【输出】一个整数，即不定方程的非负整数解组数。 【输入样例】 2 3 18【输出样例】 4 一般解法： 暴力循环： 1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; static int count=0; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int a=in.nextInt(); int b=in.nextInt(); int c=in.nextInt(); f(a,b,c); System.out.println(count); &#125; private static void f(int a, int b, int c) &#123; for(int i=0;i&lt;100;i++) &#123; for(int j=0;j&lt;100;j++) &#123; if(a*i+b*j==c) &#123; count++; &#125; &#125; &#125; &#125;&#125; 运行结果： 2 3 18a=2 b=3 c=180*a+6*b=183*a+4*b=186*a+2*b=189*a+0*b=18不定方程的非负整数解组数：4 上述解法虽然得出了正确解，但是若a、b、c的值取得很大，则此方法失效。 改进解法1： 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int a=in.nextInt(); int b=in.nextInt(); int c=in.nextInt(); System.out.println("a="+a+" b="+b+" c="+c); System.out.println("不定方程的非负整数解组数："+f(a,b,c)); &#125; private static int f(int a, int b, int c) &#123; int count=0; for(int i=0;i&lt;=c/a;i++) &#123; for(int j=0;j&lt;=c/b;j++) &#123; if(a*i+b*j==c) &#123; System.out.println(i+"*a"+"+"+j+"*b="+c); count++; &#125; &#125; &#125; return count; &#125;&#125; 运行结果： 2 3 18a=2 b=3 c=180*a+6*b=183*a+4*b=186*a+2*b=189*a+0*b=18不定方程的非负整数解组数：4 此解法相对于暴力遍历的关键处在于减少了遍历的次数：for(int i=0;i&lt;=c/a;i++) ，for(int j=0;j&lt;=c/b;j++) 【注】：千万不能写成：for(int i=0;i&lt;c/a;i++) ，for(int j=0;j&lt;c/b;j++) 。否则会忽略x与y等于0的情况 改进解法2： 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int a = in.nextInt(); int b = in.nextInt(); int c = in.nextInt(); System.out.println("a="+a+" b="+b+" c="+c); System.out.println("不定方程的非负整数解组数：" + f(a, b, c)); &#125; private static int f(int a, int b, int c) &#123; int count = 0; int x0 = 0, y0 = 0; //1.先求出一组特殊姐 for (x0 = 0; x0 &lt;= c / a; x0++) &#123; y0 = (c - a * x0) / b; if (a * x0 + b * y0 == c) &#123; break; &#125; &#125; //2.求通解， x = x0 +bt; y = y0 - at int x, y; for(int t = -100; t &lt; 100; t++)&#123; x = x0 + b * t; y = y0 - a * t; if (a * x + b * y == c&amp;&amp; x&gt;=0 &amp;&amp; y&gt;=0) &#123; System.out.println(x+"*a"+"+"+y+"*b="+c); count++; &#125; &#125; return count; &#125;&#125; 运行结果： 2 3 18a=2 b=3 c=180*a+6*b=183*a+4*b=186*a+2*b=189*a+0*b=18不定方程的非负整数解组数：4]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>不定方程求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的路径]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[问题描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 时间限制：1秒 空间限制：32768K public class Solution { public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) {​​ } } 解题思路题中所给代码hasPath方法参数含义： char[] matrix：用一位数组表示矩阵 int rows, int cols：矩形的行列数 char[] str：需要在矩形中找寻路径的字符串，待判定的字符串 寻找路径：实际上是判断每次走到的格子是否满足题目要求，第一次走： 这个格子中的字符==str的第一个字符 这个格子没有被走过 这个格子的横坐标、纵坐标未超出范围 当满足以上三点条件之后，表示该格子可以走，然后再对该格子的上下左右四个格子进行以上三点判断，重复1、2、3； 若上下左右四个格子中的某一个格子符合1、2、3三点要求，则重复4； 当待判定的字符串已经判断到了最后一个字符，说明成功找到路径。 我的代码123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; //创建一个与matrix同长度的标志数组，默认赋值false,若该格子已经被走过，则赋值true boolean[] flag = new boolean[matrix.length]; //遍历矩阵中的每一个格子 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123;//find()：循环遍历矩阵格子，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法 if(find(matrix, x, y, flag, str, 0, rows, cols)) &#123; return true; &#125; &#125; &#125; return false; &#125;//x、y：当前格子的横纵坐标 k:str中正在进行匹配的第k+1个字符（str[k]) private static boolean find(char[] matrix, int x, int y, boolean[] flag, char[] str, int k, int rows, int cols) &#123; if(k==str.length-1) &#123;//当待判定的字符串已经判断到了最后一个字符，说明成功找到路径 return true; &#125; int index=x*cols+y;//通过当前格子的横纵坐标求出该格子在matrix中对应下标 /* 若 横纵坐标超出合理范围 或者 当前格子≠str[k] 或者 当前格子被走过 都表示当前格子不可用， 返回false，返回至hasPath方法继续寻找矩阵中第二个起点等于str第一个元素的值 */ if(x&lt;0||y&lt;0||x&gt;=rows||y&gt;=cols||str[k]!=matrix[index]||flag[index]) &#123; return false; &#125; flag[index]=true;//当前格子可走,将标志数组对应元素赋值为true，表示以及走过 //对 当前格子的上下左右四个格子的字符进行判断，寻找与str[k+1]相匹配的第二个格子 if(find(matrix, x-1, y, flag, str, k+1, rows, cols)|| find(matrix, x+1, y, flag, str, k+1, rows, cols)|| find(matrix, x, y-1, flag, str, k+1, rows, cols)|| find(matrix, x, y+1, flag, str, k+1, rows, cols)) &#123; return true; &#125; flag[index]=false;//此路不通，将上面的true还原（回溯） return false;//返回false至hasPath方法，寻找其他路径 &#125;&#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数006：极限的应用02]]></title>
    <url>%2F2019%2F02%2F27%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0006%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A802%2F</url>
    <content type="text"><![CDATA[1.连续的定义 2.间断点的定义与分类定义： 间断点的分类： 左右极限都存在的间断点是第一类间断点，其中左右极限相等的间断点称为可去间断点，左右极限不等的间断点称为跳跃间断点。 左右极限至少有一个不存在的间断点称为第二类间断点。 3.连续函数的运算性质 两个连续函数的和、差、积、商(分母≠0)所得的函数仍是连续函数。 连续函数复合连续函数所得的函数仍是连续函数。(只有连续复合连续才仍是连续，其他情况不一定是连续，也不一定不是连续) 基本初等函数在其定义域内连续。 初等函数在其定义区间内连续。]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数与最小公倍数：辗转相除法]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%9A%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知两个数x和y，求x和y的最大公约数 暴力循环求解： 12345678910111213public static void gcd(int x, int y) &#123; if (y &gt; x) &#123;//如果y&gt;x，交换x与y int t = x; x = y; y = t; &#125; for (int i = y; i &gt; 0; i--) &#123; if (x % i == 0 &amp;&amp; y % i == 0) &#123; System.out.println(i); break; &#125; &#125;&#125; 辗转相除法求解： 1234567891011public static void gcd(int x, int y) &#123; while(true) &#123; if(y==0) &#123; System.out.println(x); break; &#125; int t=y; y=x%y; x=t; &#125; &#125; 辗转相除法递归求解： 1234567public static void gcd(int x, int y) &#123; if (y == 0) &#123; System.out.println(x); return; &#125; gcd(y, x % y);&#125; 理解辗转相除法： 最小公倍数： 【定理】：两个数的乘积等于这两个数的最大公约数与最小公倍数的积，即（a，b）×[a，b]=a×b，a，b的最大公约数记为（a，b），a，b的最小公倍数记为[a，b]。 所以[a，b]=a×b / (a，b) 两个数的最小公倍数求解： 123456789101112131415161718192021import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int x = in.nextInt(); int y = in.nextInt(); System.out.println(lcm(x, y)); &#125; public static int lcm(int x, int y) &#123;//求两个数的最小公倍数 return (x*y)/gcd(x,y); &#125; public static int gcd(int x, int y) &#123; if (y == 0) &#123; return x; &#125; return gcd(y, x % y); &#125;&#125; 求多个数的最大公约数和最小公倍数： 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; int[] nums = &#123; 27, 18, 9, 81 &#125;; System.out.println("最大公约数：" + gcdMore(nums, 3)); System.out.println("最小公倍数：" + lcmMore(nums, 3)); &#125; public static int gcd(int x, int y) &#123; if (y == 0) &#123; return x; &#125; return gcd(y, x % y); &#125; public static int lcm(int x, int y) &#123;// 求两个数的最小公倍数 return (x * y) / gcd(x, y); &#125; private static int gcdMore(int[] nums, int n) &#123;// 求多个数的最大公约数 if (n == 1) return nums[n - 1]; return gcd(nums[n - 1], gcdMore(nums, n - 1)); &#125; private static int lcmMore(int[] nums, int n) &#123;// 求多个数的最小公倍数 if (n == 1) return nums[n - 1]; return lcm(nums[n - 1], lcmMore(nums, n - 1)); &#125;&#125; 讲解： 求n个数的最大公约数:采用递归。与求两个数的最大公约数一样，先将前面n-1个数的最大公约数求出来，再与第n个数进行辗转相除； 求n个数的最小公倍数:采用递归。与求两个数的最小公倍数一样，先将前面n-1个数的最小公倍数a求出来，再求该a与第n个数的最小公倍数； 参考1 参考2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>辗转相除法</tag>
        <tag>最大公约数</tag>
        <tag>最小公倍数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数005：极限的应用01]]></title>
    <url>%2F2019%2F02%2F26%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0005%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A801%2F</url>
    <content type="text"><![CDATA[1.无穷小的定义 2.无穷小的比较 3.无穷小的性质 4.无穷小的运算规则 5.无穷大的定义 6.几个常用的无穷大 7.无穷大与无界的关系无穷大是无界，无界未必是无穷大. 8.无穷大与无穷小的关系]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2n皇后问题]]></title>
    <url>%2F2019%2F02%2F26%2F2n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[思路： 实现解题的三步走： 1)第一步，从第一行的第一个进行放置皇后（先放黑或白都可以），然后首先要进行的是对当前位置能否放置皇后的判断，若是1，则可以放；否则不能放。如果不能放，则进行第一行的第二个的位置判断。如果是1，则进行第二步。 2)第二步，是在满足当前位置的值为1的情况下，进行“同一行、同一列或同一条对角线上，任意的两个白（黑）皇后都不在同一行、同一列或同一条对角线上”的判断，而判断的顺序为当前位置的上面，左对角线，右对角线是否有已经放过的白（黑）皇后，若有，则返回值为false，即该点不能进行白（黑）皇后的放置。则进行了同一行的下一位置的判断，依然是第一步和第二步的判断。若没有，则返回true，即该点可以放置，进行第三步操作。 3)第三步，在经过前两步的判断过后，则需要对通过判断的位置进行皇后的放置，白皇后用2表示，黑皇后用3表示，即对通过前两步判断的位置进行2或3的赋值。然后进行下一行第一个位置的放置。然后是回溯法的重点，当完成所有的放置，或满足不了放置的条件则需要将放置了皇后的点的值改变为原来的1。如果四个白皇后都放置完了，则进行黑皇后的放置，而黑皇后也满足了皇后个数的放置则表示找到了一种方法，计数变量进行加一操作。若过程中没有满足皇后的个数，进行上一步的回溯，下一位置继续进行判断，以此类推。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Scanner;public class Main &#123; static int n;//待输入的整数n，表示期盼的大小 static int sum;//记录摆法的个数，即最终返回的结果 static int[][] arr;//二维数组表示棋盘 public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); n = in.nextInt(); arr = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; arr[i][j] = in.nextInt(); &#125; &#125; DFS(0, 2);//从第一行开始，对白皇后进行放置，0表示第一行的下标，2表示白皇后 System.out.println(sum); &#125; private static void DFS(int x, int num) &#123; if (x== n) &#123; //达到最后一行，当前颜色皇后放置完毕 if(num==2)DFS(0,3); //如果当前摆放完毕的是白皇后，则进行黑皇后的放置 else sum++;//否则表示摆放完毕的是黑皇后，放置方法找到了一种，计数变量进行值加一 return ; &#125; for (int y = 0; y &lt; n; y++) &#123;//对当前行的各个位置进行判断能否摆放,y表示纵坐标 if(arr[x][y]!=1) &#123;//若当前位置不为1，表示不能摆放 continue;//对当前位置的下一坐标点进行判断,即x不变，y+1 &#125; if (Check(x,y,num)) &#123; /*Check：判断当前位置进行同行、同列、同对角线上是否已经放置了当前颜色的皇后， *若存在已放置皇后，则当前位置不能放置皇后，返回false，否则返回true */ arr[x][y]=num;//返回true，当前位置可放,将当前坐标值赋为2（2:白皇后;3:黑皇后） &#125;else &#123; continue;//返回false，当前位置不可放，对当前行的下一位置进行判断 &#125; DFS(x+1,num); // 开始摆放下一行(x+1)的皇后，同样从第0列开始摆放 arr[x][y]=1 ;// 每次摆放完一种皇后后，都要将其撤回，再试探其它的摆法。“回溯” &#125; &#125; public static boolean Check(int x,int y,int num)//满足题目要求的判断函数 &#123; for(int preX=x-1;preX&gt;=0;preX--) &#123; //当前位置上方是否进行了相同皇后的放置 这行以下的还没放不检查 （同行检查） if(arr[preX][y]==num) return false; &#125; for(int preX=x-1,perY=y-1;preX&gt;=0&amp;&amp;perY&gt;=0;preX--,perY--) &#123; //检查左对角线 这行以下的还没放不检查 （左对角线检查） if(arr[preX][perY]==num) return false; &#125; for(int preX=x-1,perY=y+1;preX&gt;=0&amp;&amp;perY&lt;=n-1;preX--,perY++) &#123; //检查右对角线 这行以下的还没放不检查 （右对角线检查） if(arr[preX][perY]==num) return false; &#125; return true;//都满足的情况下，则可以进行当前皇后的放置 &#125; &#125; 注:代码段中的Check();方法没有对同一行之前的位置进行判断，是因为同一行是从左到右依次放置的，若前面放了则直接是下一行的判断，不会是相邻右侧的位置进行放置，则不需要进行判断，同理右侧，下方都不用，因为还没有进行皇后的放置，本题是回溯法经典的应用，递归的思想。若想深刻的领悟，应该跟着程序一步步的进行解读，进行逐渐的理解，掌握递归的思想，回溯的精髓。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数004：极限的计算]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0004%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[求极限的方法（仅限当前所学内容，后续还会有零零散散的方法） 方法一：利用四则运算与基本极限求极限 常见的基本极限有： [例]： 方法二：利用等价代换求极限 方法三：利用夹逼准则求极限 方法四：利用单调有界准则求极限 单调增且有上界，则极限存在； 单调减且有下界，则极限存在。]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归：总金额出错账单明细]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%80%92%E5%BD%92%EF%BC%9A%E6%80%BB%E9%87%91%E9%A2%9D%E5%87%BA%E9%94%99%E8%B4%A6%E5%8D%95%E6%98%8E%E7%BB%86%2F</url>
    <content type="text"><![CDATA[【问】：某财务部门结账时发现总金额不对头。很可能是从明细上漏掉了某1笔或几笔。如果已知明细账目清单，能通过编程找到漏掉的是哪1笔或几笔吗？ 如果有多种可能，则输出所有可能的情况。 我们规定：用户输入的第一行是：有错的总金额。 接下来是一个整数n，表示下面将要输入的明细账目的条数。 再接下来是n行整数，分别表示每笔账目的金额。 要求程序输出：所有可能漏掉的金额组合。每个情况1行。金额按照从小到大排列，中间用空格分开。 比如： 用户输入： 6 5 3 2 4 3 1 表明：有错的总金额是6；明细共有5笔。此时，程序应该输出： 1 3 3 1 2 4 3 4 为了方便，不妨假设所有的金额都是整数；每笔金额不超过1000，金额的明细条数不超过100。 我的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Arrays;import java.util.HashSet;import java.util.Scanner;public class Main &#123; static HashSet&lt;String&gt; set=new HashSet&lt;String&gt;();//存储所有可能漏掉的金额组合 public static void main(String[] args)&#123; Scanner in=new Scanner(System.in); int err_sum=in.nextInt();//有错的总金额 int N=in.nextInt();//下面将要输入的明细账目的条数 int[] a=new int[N];//存储每笔账单金额 int k=0; for (int i = 0; i &lt;N ; i++) &#123; a[i]=in.nextInt(); &#125; Arrays.sort(a);//为了满足金额按照从小到大排列 boolean[] b=new boolean[N]; f(err_sum,a,k,b,0); for (String str : set) &#123; System.out.println(str); &#125; &#125; private static void f(int err_sum, int[] a, int k, boolean[] b, int curr_sum) &#123; String s=""; if (curr_sum&gt;err_sum) &#123; return; &#125; if (err_sum==curr_sum) &#123; for (int i = 0; i &lt; b.length; i++) &#123; if (b[i]==false) &#123; s+=a[i]+" "; &#125; &#125; set.add(s); return ; &#125; if (k==a.length) &#123;//当 当前元素等于最后一个元素时，遍历完毕 return; &#125; b[k]=false;//没有这一步也行，因为数组b默认初始为false f(err_sum, a, k+1, b, curr_sum); curr_sum+=a[k];//是否加上当前项，现一加上，置为true b[k]=true; f(err_sum, a, k+1, b, curr_sum); b[k]=false;//回溯，以便后一次遍历恢复原来数据 &#125;&#125; 讲解： 1234567b[k]=false; f(err_sum, a, k+1, b, curr_sum); curr_sum+=a[k]; b[k]=true; f(err_sum, a, k+1, b, curr_sum); b[k]=false; 每遍历到数组a中某一元素a[k]，都有取与不取两种情况： 不取：将此元素标记为false,即b[k]=false，然后继续遍历下一元素a[k+1] 取：curr_sum加上a[k]，并将此元素标记为true， 即b[k]=true，然后继续遍历下一元素。]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙变态跳台阶]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%9D%92%E8%9B%99%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[【请先食用上一篇】：青蛙跳台阶 问:一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路: 一共有n级台阶，第一次跳青蛙可以跳1，2，3……n级台阶 假设：f(n)表示：n个台阶第一次1,2,…n阶的跳法数;若第一次跳了1阶，则还剩n-1阶，假设：f(n-1)表示：n-1个台阶第一次1,2,…n-1阶的跳法数;若第一次跳了2阶，则还剩n-2阶，假设：f(n-2)表示：n-1个台阶第一次1,2,…n-2阶的跳法数;把所以可能的情况（第一次可能跳1,2,…,n阶）加起来：可以求出：f(n) = f(n-1) + f(n-2) + … + f(1)递归：f(n-1) = f(n-2) + … + f(1)可以求出：f(n) = 2*f(n-1) 看图理解： 我的代码： 1234567891011public class Solution &#123; public int JumpFloorII(int target) &#123; if(target==1)&#123;//当台阶数为1时，只有一种跳法 return 1; &#125; if(target==0)&#123; return 0; &#125; return 2*JumpFloorII(target-1); &#125;&#125; 更实用的解法是：从下往上计算，避免了递归的多余计算量 123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; int a = 1, b = 0; if (target &lt;= 0) &#123; return 0; &#125; else if (target == 1) &#123; return 1; &#125; else &#123; for (int i = 2; i &lt;= target; i++) &#123; b = 2 * a; a = b; &#125; return b; &#125; &#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开学愉快：返程]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%BC%80%E5%AD%A6%E6%84%89%E5%BF%AB%EF%BC%9A%E8%BF%94%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[视频如下：]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典递归问题：求两个字符串的最长公共子序列的长度]]></title>
    <url>%2F2019%2F02%2F17%2F%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%EF%BC%9A%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[公共子序列与公共子串的区别 公共子序列是在整个字符串中只要按照顺序可以不用连续的，但是公共子串是指必须连续的字符串，举个例子: ABCBDABBDCABA 最长公共子序列是 : BCBA 最长公共字串是 : AB 递归【思路】： 先将两个字符串的第一个字符进行比较： 两串的第一个字符相同：再将两字符串剩余子串进行继续比较 两串的第一个字符不同：①.将串1的剩余子串与串2整串进行比较；②.将串2的剩余子串与串1整串进行比较→①和②中的较大者即为最大公共子序列长度 123456789101112131415public class Main &#123; public static void main(String[] args)&#123; int len=f("viced","viecddh"); System.out.println(len); &#125; private static int f(String s1, String s2) &#123; if(s1.length()==0||s2.length()==0)&#123;//当某一字符串长度为0时表示其中一个字符串比较完毕 return 0; &#125; if(s1.charAt(0)==s2.charAt(0))&#123;//第一个字符相同 return f(s1.substring(1),s2.substring(1))+1; &#125;else&#123;//第一个字符不同 return Math.max(f(s1.substring(1),s2),f(s1,s2.substring(1))); &#125; &#125; 动态规划当所比较的两个字符串非常长时，采用递归重复的子问题多，效率低下，求解很容易发生栈溢出，改进的办法——用空间换时间，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了。 123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args)&#123; int len=f("viceddgbgfhb","viecddhjnghjghjgjgh"); System.out.println(len); &#125; private static int f(String str1, String str2) &#123; int len1 = str1.length(); int len2 = str2.length(); int c[][] = new int[len1+1][len2+1]; for (int i = 0; i &lt;= len1; i++) &#123; for( int j = 0; j &lt;= len2; j++) &#123; if(i == 0 || j == 0) &#123; c[i][j] = 0; &#125; else if (str1.charAt(i-1) == str2.charAt(j-1)) &#123; c[i][j] = c[i-1][j-1] + 1; &#125; else &#123; c[i][j] = Math.max(c[i - 1][j], c[i][j - 1]); &#125; &#125; &#125; return c[len1][len2]; &#125;&#125; 参考：https://blog.csdn.net/qq_31881469/article/details/77892324]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典递归问题：全排列问题]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【题目】设计一个递归算法生成n个元素{r1,r2,…,rn}的全排列。 【算法讲解】： 设R={r1,r2,…,rn}是要进行排列的n个元素，Ri=R-{ri}。集合X中元素的全排列记为perm(X)。(ri)perm(X)表示在全排列perm(X)的每一个排列前加上前缀得到的排列。R的全排列可归纳定义如下：当n=1时，perm(R)=(r)，其中r是集合R中唯一的元素；当n&gt;1时，perm(R)由(r1)perm(R1)，(r2)perm(R2)，…，(rn)perm(Rn)构成。 实现思想：将整组数中的所有的数分别与第一个数交换，这样就总是在处理后n-1个数的全排列。 【示例】 当n=3，并且E={a，b，c}，则：perm(E)=a.perm({b,c}) + b.perm({a,c}) + c.perm({a,b})perm({b,c})=b.perm(c) + c.perm(b)a.perm({b,c})=a.b.perm(c) + a.c.perm(b)​ =a.b.c + a.c.b=(abc, acb) 我的代码： 12345678910111213141516171819public class Main &#123; public static void main(String[] args)&#123; char[] data="ABC".toCharArray(); f(data,0); &#125; private static void f(char[] data,int k) &#123; if(k==data.length)&#123;//只剩下一个元素 for(int i=0;i&lt;data.length;i++)&#123; System.out.print(data[i]+" "); &#125; System.out.println(); &#125; for(int i=k;i&lt;data.length;i++)&#123; &#123;char c=data[k];data[k]=data[i];data[i]=c;&#125;//试探 f(data,k+1); &#123;char c=data[k];data[k]=data[i];data[i]=c;&#125;//回溯 &#125; &#125;&#125; 关于回溯： 3个电灯串联在一起，其中有个灯泡坏了，通过在灯泡正负极接上一根导线的方法来筛选出坏了的灯泡，每次检测下一灯泡时，必须先将连在上一灯泡的导线取下，保持在最初状态，这就是回溯。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数003：极限的定义与性质]]></title>
    <url>%2F2019%2F02%2F13%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0003%EF%BC%9A%E6%9E%81%E9%99%90%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[极限的定义 自变量 x 的描述 因变量f(x)的描述 [定义]： 注释: 举例说明: 其他注释： [定理]： 思考：既然极限分为左侧和右侧，极限存在的要求是存在左极限与右极限且二者相等,那么计算时是否需要分别针对左极限和右极限进行求解呢？ 答案为看情况，以下是需要考察左右极限的3种情形： 需要考察左右极限的3种情形: 例题: 极限的性质]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青蛙跳台阶]]></title>
    <url>%2F2019%2F02%2F13%2F%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述： 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路： 我们先考虑青蛙第一跳： 第一次跳1个台阶，那么还剩n-1个台阶，跳法为f(n-1) 第一次跳2个台阶，那么还剩n-2个台阶，跳法为f(n-2) 所以总的跳法:f(n)=f(n-1)+f(n-2) 当跳到只剩1个台阶时，有1种跳法：f(1)=1 当跳到只剩2个台阶时，有2种跳法：f(2)=2 观察发现，这就是一个斐波那契数列 我的代码： 123456789101112public int JumpFloor(int target) &#123;//target为台阶总数 if(target==2)&#123; return 2; &#125; if(target==1)&#123; return 1; &#125; if(target&lt;=0)&#123; return 0; &#125; return JumpFloor(target-1)+JumpFloor(target-2); &#125; 运行时间：544ms 占用内存：9056 k 改进： 为避免递归产生的栈溢出，改用自底向上的动态规划（迭代）来解题： 123456789101112131415161718public int JumpFloor(int target) &#123; if(target==2)&#123; return 2; &#125; if(target==1)&#123; return 1; &#125; if(target&lt;=0)&#123; return 0; &#125; int first = 1, second = 2, third = 0; for (int i = 3; i &lt;= target; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125; 运行时间：15ms 占用内存：9328 k]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要自称为程序员]]></title>
    <url>%2F2019%2F02%2F12%2F%E4%B8%8D%E8%A6%81%E8%87%AA%E7%A7%B0%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[转自: 开发者技术前线 每年都有无数年轻程序员，加入软件行业。他们在学校 里学 过 编程，但是对这行业的现实一无所知，现在来听听资 深 的软件工程师，介绍这个行业的一些实际情况 。 一 、 90% 的 编 程 工 作 来 自 内 部 软 件 计算机专业的学生，可能有一种错觉，觉得大部分程序员，都在编写公开出售的软件或者通用软件。 这种看法是不对的。大部分程序员，实际上编写的是不公开的企业内部软件，比如追踪费用的软件、优化装运成本的软件、帮助记账的软件、设计新部件的软件、计算保单价格的软件、识别恶意订单的软件等等。 各种各样的商业公司，开发内部软件，解决它们自己的问题。市场上对程序员的大部分需求来源于此，只有极少数程序员直接编写面向外部顾客的软件。 内部软件的开发，通常非常乏味，令人厌倦。因为它们的技术复杂性低、技术决策非常保守、预算很少、缺乏长远考虑。但是，世界上大部分编程工作都是这种。你如果想入行程序员，你就要有心理准备去接受这样的工作。 二、别人雇你的目的，是让你创造利润，不是让你编程 商业公司最关心的（或者说唯一在乎的）事情，就是增加收入、降低成本。因此，它们实际上需要的不是程序员，而是能够帮助它们增加收入、降低成本的人。 开发优美的软件，解决技术难题，编写没有 bug 的代码，这些都不是商业公司的目的。它们雇佣你，是为了让你帮它们完成某个可以增加收入、降低成本的项目，而不是为了让你追求个人的软件成就。 你对于公司的唯一价值，就在于能多大程度上为它们增加收入、降低成本。 三、好的程序员专注于为公司带来价值 很多公司的经理不懂计算机，在他们心目中，程序员就是一群高成本的劳动力，只会在一台复杂的机器上干一些难懂的事情。 如果你自称为”码农”，只会写代码。当公司需要压缩成本的时候，某些经理首先就会想到解雇你，因为你的工资高。 有一家公司叫 Salesforce，口号是”没有软件”，意思就是如果经理们购买了他们的服务，就不再需要别的软件管理销售业务了，也就是说，不再需要自己雇佣程序员了。 正确的做法是，你应该把自己描述成与增加收入、降低成本有关系的人，比如”xx产品的开发者”或”改进者”。有一个 Google Adsense 程序员的自我介绍，是这样写的：”Google 公司97%的收入，与我的代码有关。 四、不要限定自己 年轻学生经常会问，应该选择哪种语言或平台？Java 是不是比 .NET 容易找工作？ 过分强调某一种语言或平台，都是不必要的。如果你把自己限定为 Java 程序员或 .NET 程序员，你就已经输了，因为首先你不应该自称为程序员（理由见上一点），其次这种限定使得你自动被排除在世界上大多数编程工作之外。 现实生活中，学会一种新语言，只需要一两个月，然后再过半年到一年，你就会变成老手。那时，根本没人在乎你以前用什么语言。 天才程序员是很少的，可是需要天才程序员的工作机会却很多很多，大多数场合都是需求远远大于供给。 这意味着，即使你不是天才程序员，只要你是一个优秀工程师，那些招聘公司也会立刻录用你，因为它们知道招聘到天才程序员的机会微乎其微。（重复一遍，所谓”优秀工程师”，就是你的履历上有一连串可以为公司增加收入、降低成本的记录。） 某些公司的人事部门，会根据某个关键词（比如 Java 或 .NET）过滤简历。虽然这样的公司根本不值得去，但是如果你真的想过这一关，也很容易：投入几个晚上和周末，在你当前的项目中设法用到这个关键词，然后再把它写进简历就行了。 五、如何提高求职时的谈判能力？ （1）记住你不是在求职，不是在展示编程技巧，而是在推销某种商业问题（增加收入或降低成本）的解决方案。 （2）面试时，要有自信，要平等的对话。你要的是一个互利的录用合同，不要每次对方提出要求，你都说Yes。 （3）雇主可能会问”你的上一份工资是多少”，他们其实在说”给我一个理由，压低你的报酬”。你要想好如何适当地回答这个问题。 （4）要还价。这里不仅仅指钱，还指其它你关心的方面。如果你无法要求更高的薪水，那就试着要求更多的假期。 六、创业公司是否适合应届毕业生？ 如果你一毕业就加入创业公司，最可能的结果是，接下来几年你都工作得非常辛苦，然后公司悲惨地失败了，你失业了，不得不又去另一家创业公司工作。 如果你真的想去创业公司，应该首先找一家大公司干上两年，攒一点钱，积累一些经验，然后精心挑选一家创业公司，再去实现自己的梦想。 在创业公司工作，一般情况下，你遇到的都是创业者。他们大多数人没有能力在两年后雇佣你；而在大公司工作，你遇到的都是其他大公司的人，他们中很多人将来有能力雇用你或者帮你介绍工作。 七、沟通技能是最重要的职业技能 前面说过，工程师被雇佣，不是因为会编程，而是因为能够创造商业价值。所以，你得让人们相信你能创造价值，这是帮助你找到工作的最重要的能力。这种能力与你真的能创造多少价值，实际上联系不是很紧密。很多情况下，你向别人展示的是对你能力的一种期望，而不是你当前的能力。]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划：斐波那契数列]]></title>
    <url>%2F2019%2F02%2F09%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[问： 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 斐波那契数列简单介绍 我的解法： 123456public static int Fibonacci(int n) &#123; if(n &lt;= 1)&#123; return n; &#125; return Fibonacci(n-1)+Fibonacci(n-2); &#125; 注：从Fibonacci(n-1)+Fibonacci(n-2)明显看出使用的是递归，此题用递归两三行代码即可搞定。但是，若出题者准备着一个超大的n，那么很有可能会 Stack Overflow（递归的本质就是栈），为什么会栈溢出？因为重复计算，举个栗子： 当n=4时， Fibonacci(4) = Fibonacci(3) + Fibonacci(2) ​ = Fibonacci(2) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0) ​ = Fibonacci(1) + Fibonacci(0) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0); 由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时Fibonacci(1)就重复计算了3次之多。 其他解法： 1234567891011121314public int Fibonacci(int n) &#123; int preNum=1; int prePreNum=0; int result=0; if(n&lt;=1) return n; for(int i=2;i&lt;=n;i++)&#123; result=preNum+prePreNum; prePreNum=preNum; preNum=result; &#125; return result; &#125; 注：动态规划（Dynamic Programming）。 动态规划简单介绍：https://blog.csdn.net/u013309870/article/details/75193592 动态规划算法也可以说是 ‘记住求过的解来节省时间’; 动态规划算法的核心就是记住已经解决过的子问题的解。 上述代码需要用到三个数进行操作（preNum、prePreNum、result），实际上可以简化为两个数，从而节省空间，代码如下： 12345678public static int Fibonacci(int n) &#123; int pre = 0, next = 1; while(n--&gt;0) &#123; next += pre; pre = next - pre; &#125; return pre; &#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数002：复合函数+反函数+基本初等函数+初等函数]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0002%EF%BC%9A%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8D%E5%87%BD%E6%95%B0%2B%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[复合函数 反函数 基本初等函数初等函数由常数和基本初等函数经过有限次数的四则运算与有限次数的负荷运算，并能用一个式子表示的函数，称为初等函数.]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019美赛赛后回顾+总结]]></title>
    <url>%2F2019%2F02%2F06%2F2019%E7%BE%8E%E8%B5%9B%E8%B5%9B%E5%90%8E%E5%9B%9E%E9%A1%BE%2B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言2018年的最后一个学期临近结束之际，学校机器人中心传来了美赛报名的消息。 找不到给力的队友； 想利用寒假专心准备3月份的蓝桥杯和考研复习（结果现在寒假临尽却没怎么准备这两项）； 更想参加2019年的国赛（此时还不知道美赛比国赛规模更大）。 基于这几点原因，一开始没打算报名美赛，但离报名结束没几天，实验室一名同学孙同学突然找到我邀我组队参赛，由于上次的宁夏建模赛我和他的队伍都获奖了，所以觉得队友应该靠得住，便同意组队参赛了，也开始将MATLAB等系列软件重新安装回了电脑。 赛前准备相对宁夏赛和国赛临时拉凑的两名队友来说（没有贬低当初队友之意，只是当时我们三个都没有参赛经验，能力不足），此次的两名队友更显专业和强大。在赛前几天，我们对赛时如何让沟通进行了线上探讨（由于美赛期间我们都已放假回家，所以我们比赛4天4夜都要靠线上交流，相对宁夏赛和国赛来说，增加了一定的限制与难度），王同学（队长）给出了沟通方案： 通过QQ群语音交流，借助TeamViewer软件辅助之； 论文写作依靠石墨文档（并且王还将每个人负责论文哪几块部分进行了分工）； 王还在我们三个人的群里发了一些美赛注意事项等文献文档； 除上述之外，王还提供了番羽土啬的工具和方法，让我在比赛期间可以尽情访问Google（对我用处颇大）。 还有许多细节，在此不一一赘述。通过这些，我发现王是一个做事很有条理的严谨之人，也是一名强大的队友+负责的队长，让我不论是在技术还是处事方法上都受益颇多，另一名队友孙同学赛前在群里发言较少，但也是一名很强大的队友，对很多数学模型有有所了解，代码技术上比我和王都要强（这在比赛中有所体现）。在赛前，我阅读了一些历年的优秀美赛获奖论文并将自己拥有的一些资料共享到了群里，在大致准备完毕之后，我们在比赛前一晚都早早睡去，准备以最饱满的精神状态迎接第二天凌晨6点的美赛开题。 比赛开始2019年1月25日凌晨6点，我早早起了床，洗漱完毕，在电脑面前等待着开题，当然，还有我的队友一起。没多久，ABCDEF六道题全部出炉，我们三个对各题进行了浏览： A题：我们首先同时对A题进行了阅读，A题是假设恐龙生存在现代，让我们对龙的特征、行为、习惯、饮食和生存所需环境等方面进行分析； B题：2017年飓风袭击了美国的波多黎各，造成了大量伤亡和交通的瘫痪。一家公司企图设计一种由 无人机+医疗包 组合而成的灾害应对系统运往灾区进行医疗运输和道路侦察。要求我们对1.集装箱、无人机、医疗包的装箱进行研究；2.集装箱在灾区的安置点的选址进行确定；3.针对医疗运输和道路侦察两方面分别对无人机进行排班； C题：美国阿片药物危机（美国吸毒泛滥）。此题给出了庞大的数据，基于这些数据进行题目分析与作答。 D题：开发卢浮宫紧急疏散模型…… 我们只阅读了ABCD三道题，后面在B和D之间进行纠结。（我觉得A题关于恐龙google查询出的结果资料太过少，难以解题；C题数据太过庞多，不易掌控，且我对这种大量数据分析类题目好感不佳；）王和孙一开始都想选D题，因为从孙的发言中貌似有了D题的大致解题思路，而我却对B题情有独钟： 因为ABC属于MCM，而DEF属于ICM，两者在难易程度、评比、题型等各方面都有所差别（MCM更难），D题虽然题目容易理解（看完题就知道要我们干什么），但肯定会有大量团队选择这道题，在难度较小，选题者众多的情况下，要想获奖及必须在保证解题正确的情况下突出解题的创新性；B题难度较大（看完题我们3人都不知道题目要我们干什么，该如何下手），但选择的人肯定会少很多，在难度较大、选题者少的情况下，只要解题正确、逻辑连贯合理就很容易拿奖。 我将我的上述想法分享给了王和孙，王应该利用小号最加了数学建模类的群（神秘群），分享给了我们一些该群的各题解题参考思路，最终我们决定先试着解B题，若长时间没有思路则放弃B题转攻D题。 开始解题(简单叙述)我们3个对B题进行了多次阅读，但仍没有完全搞懂B的意思，于是我们打算摸着石头过河，边走边看，我们先对第一问进行了分析，我们研究出第一问就是要我们筛选出性能最佳的无人机和医疗套餐，并制定出它们的装箱方案。我们试了很多种方法，但第一天结束都没有将第一问解出来，当天晚上，我们搜集到网上的一个思路参考视频，确定了大致的解题思路（途中历经了各种方法尝试但都无果，过程十分痛苦，在此不做赘述，只道最后解决方案）。最后，第一问孙同学完成了无人机和医疗套餐的筛选以及该部分论文的写作，我完成了无人机+医疗包的数量确定（我列出了多目标多约束方程，但解不出，最后孙解出来了），随后我完成了该部分论文的写作，至于装箱问题，我们一开始无从下手，直至比赛最后一天才解决。完成了这些，已经过去了两天两夜的时间。 我们通过思路视频了解到第二问是B题重中之重，利用软件ArcGIS可有效解题，于是我们安装了ArcGIS,但……我们用不来！！！我们花了很长很长很长的时间对波多黎各的各种地理数据进行查询（过程十分苦难，言之想哭），我们对ArcGIS进行了简单学习，还是无从下手（我们的3人小群也长时间不发一言，因为大家都没有思路，很是苦恼），可所剩时间不多了，还有3问等着我们解决（第三问分为两小问），于是在第三天下午，我们决定王负责论文的整理+翻译（真的很累，是个细致活），孙先试着解第三问，我则负责专攻第二问。 然后，我们便各自开始了自己的工作，我花了一下午的时间大致摸清了ArcGIS在选址方面的运用，并试着利用来之不易的数据文件进行ArcGIS求解，最终，在第三天的晚上，我奋斗到凌晨5点半（比赛结束大家聊天发现3个人都差不多一宿没睡），才完成了第二问的70%，不敌困意，睡了两个半小时，然后接着干，最终，在第四天临近中午的时候，我完成了第二问，但求出来的结果不是很理想。 （此处略去……千辛万苦、千辛万苦、千辛万苦、千辛万苦） 最后，在离提交时刻还剩不到3小时的时候，我们第三问的最后一小问并没有解出来（这一问是由我负责，我写到最后发现自己貌似写错了，加上比赛剩余时间严重不足以及第二问负荷过大，实在没有思路怎么写下去），其他题目已经大致完成求解。然后我们一起辅助王对论文进行摘要、问题分析、备忘录、参考文献等细节进行书写。 最终，在9点30左右提交了并不完美的论文，于9点45左右提交成功（提交时间为10:00）。然后发现参考文献出现了中文，估计凉了…… 赛后总结虽然我们最后并没有提交出一份完美的论文，但我们3个人都很满足，鏖战4天4夜，总共没人只睡了不到10个小时。对于我来说，得到了以下收获： 通过王我学到了做事要有准备，他真的是一个严谨细心的人，作为队长，名副其实（值得我好好学习）； 一个晚上大致学会ArcGIS使用，一个人的学习能力+资料查询能力真的非常非常重要； 认识到LaTex的强大（王是用这个软件进行论文排版），打算进行这个软件的学习； 通过孙知道了自己应该学习更多的数学建模知识； 对于一个团队来说，队友真的十分重要，强大、配合默契的队友会让你事半功倍； 英语真的相当相当相当重要； 任何事情，绝不能轻言放弃！]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>美赛</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式:懒汉式和饿汉式区别]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%87%92%E6%B1%89%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[作者：AH_HH来源：CSDN原文：https://blog.csdn.net/qq_35098526/article/details/79893628 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 【注意】： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 明确定义后，看一下代码： 饿汉式 12345678910111213141516171819202122public class SingletonEH &#123; /** *是否 Lazy 初始化：否 *是否多线程安全：是 *实现难度：易 *描述：这种方式比较常用，但容易产生垃圾对象。 *优点：没有加锁，执行效率会提高。 *缺点：类加载时就初始化，浪费内存。 *它基于 classloder 机制避免了多线程的同步问题，- 不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种， 在单例模式中大多数都是调用 getInstance 方法，- 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载， 这时候初始化 instance 显然没有达到 lazy loading 的效果。 */ private static SingletonEH instance = new SingletonEH(); private SingletonEH ()&#123;&#125; public static SingletonEH getInstance() &#123; System.out.println("instance:"+instance); System.out.println("加载饿汉式...."); return instance; &#125; &#125; 饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了。 懒汉式 123456789101112131415161718public class SingletonLH &#123; /** *是否 Lazy 初始化：是 *是否多线程安全：否 *实现难度：易 *描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 *这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */ private static SingletonLH instance; private SingletonLH ()&#123;&#125; public static SingletonLH getInstance() &#123; if (instance == null) &#123; instance = new SingletonLH(); &#125; return instance; &#125;&#125; 而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。 1、线程安全： 饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题， 懒汉式本身是非线程安全的，为了实现线程安全有几种写法。 例： 12345678910111213141516171819public class SingletonLHsyn &#123; /** *是否 Lazy 初始化：是 *是否多线程安全：是 *实现难度：易 *描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 *优点：第一次调用才初始化，避免内存浪费。 *缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 *getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 */ private static SingletonLHsyn instance; private SingletonLHsyn ()&#123;&#125; public static synchronized SingletonLHsyn getInstance() &#123; if (instance == null) &#123; instance = new SingletonLHsyn(); &#125; return instance; &#125;&#125; 2、资源加载和性能： 饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成。 而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成instance 被多次实例化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典递归问题：取球问题]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%EF%BC%9A%E5%8F%96%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【请先食用上一篇】：递归与循环 问：在n个球中，任意取出m个球(不放回)，求有多少种不同取法? 解法: 123456789101112131415161718192021222324252627import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader scan=new BufferedReader(new InputStreamReader(System.in)); System.out.println("请输入球的总数："); int n=Integer.parseInt(scan.readLine()); System.out.println("请输入取出球的个数："); int m=Integer.parseInt(scan.readLine()); int count=f(n,m); System.out.println("在"+n+"个球中，任意取出"+m+"个球(不放回)，有:"+count+" 种不同取法"); &#125; private static int f(int n, int m) &#123; if(m &gt; n)&#123; return 0; &#125; if (n == m) &#123; return 1; &#125; if (m == 0) &#123; return 1; &#125; return f(n-1,m-1)+f(n-1,m); &#125;&#125; 运行截图： 思路： 【分析】： 递归问题，往往是将问题拆解成一个与原问题相似的问题+一个现阶段容易且能够解决的小部分，如图所示： 假设左边阶梯型图形为给出的问题，解法是转化为右边图形：将原问题拆解为与原问题相似的蓝色上部分以及现阶段容易且能够解决的绿色部分。 但有时候所给出的问题往往难以直接拆分，这类问题如同一个完美无缺的圆，突破口不易观察，很难直接将问题进行拆解，正如这道取球问题，这时就需要花点技巧。 【解决】： 我们假设n个球中有一个为幸运球，这时取球问题就出现了两种情况： 幸运球一定被取出:有了这个限定条件，相当于从n个球中拿出一个球(幸运球)事先放在取球者手中(这样才能保证幸运球一定被取出)，此时取球问题就变成了从n-1个球中取出m-1个球，即f(n-1,m-1)； 幸运球一定不被取出:有了这个限定条件，相当于从n个球中剔除出一个球(幸运球)，这样才能保证幸运球一定不被取出，此时取球问题就变成了从n-1个球中取出m个球，即f(n-1,m)； 综上，从n个球中取出m个球的总取法=取法1(幸运球被取出)+取法2(幸运球不被取出)=f(n-1,m-1)+f(n-1,m). 这便满足了递归问题两大要点之一:相似性，还需要满足另一要点:出口，如下： 12&gt; if (m &gt; n) return 0;//取球数&gt;总球数，不合理，终止递归&gt; 12&gt; if (n == m) return 1;//表示从x个球中取出x个球，只有一种取法&gt; 12&gt; if (m == 0) return 1;//表示从x个球中取出0个球，也是只有一种取法（即不取）&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单一步激活Office2019]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%AE%80%E5%8D%95%E4%B8%80%E6%AD%A5%E6%BF%80%E6%B4%BBOffice2019%2F</url>
    <content type="text"><![CDATA[无需第三方破解软件 激活成功截图 激活方法新建文本文档，输入以下代码： @echo off(cd /d “%~dp0”)&amp;&amp;(NET FILE||(powershell start-process -FilePath ‘%0’ -verb runas)&amp;&amp;(exit /B)) &gt;NUL 2&gt;&amp;1title Office 2019 Activator r/Piracyecho Converting… &amp; mode 40,25(if exist “%ProgramFiles%\Microsoft Office\Office16\ospp.vbs” cd /d “%ProgramFiles%\Microsoft Office\Office16”)&amp;(if exist “%ProgramFiles(x86)%\Microsoft Office\Office16\ospp.vbs” cd /d “%ProgramFiles(x86)%\Microsoft Office\Office16”)&amp;(for /f %%x in (‘dir /b ..\root\Licenses16\ProPlus2019VL.xrm-ms’) do cscript ospp.vbs /inslic:”..\root\Licenses16\%%x” &gt;nul)&amp;(for /f %%x in (‘dir /b ..\root\Licenses16\ProPlus2019VL.xrm-ms’) do cscript ospp.vbs /inslic:”..\root\Licenses16\%%x” &gt;nul)cscript //nologo ospp.vbs /unpkey:6MWKP &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP &gt;nul&amp;set i=1:serverif %i%==1 set KMS_Sev=kms7.MSGuides.comif %i%==2 set KMS_Sev=kms8.MSGuides.comif %i%==3 set KMS_Sev=kms9.MSGuides.comcscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nulecho %KMS_Sev% &amp; echo Activating…cscript //nologo ospp.vbs /act | find /i “successful” &amp;&amp; (echo Complete) || (echo Trying another KMS Server &amp; set /a i+=1 &amp; goto server)pause &gt;nulexit 保存之后，修改文本文档后缀，将.txt修改为.bat保持联网，然后以管理员身份运行，等待数秒，即可激活。本方法通过kms密钥管理服务器激活，有效期为180天，等到180天后，又会自动联网激活，不用重复操作，然后再续180天。]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与循环]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[一.递归与循环递归，说白了就是自己调用自己。理论上，任何的循环都可以重写为递归形式，所有的递归也可以被表述成循环的形式，本文主要介绍如何将循环重写为递归。 二.循环改递归的两大要点 发现逻辑“相似性” 不要忘记递归的“出口” 小例子： 1234567public class demo&#123; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(i); &#125; &#125;&#125; 上述代码的输出结果是打印出数字“0-9”。 这是利用循环实现，接下来我们将循环改写为递归： 12345678910public class Main&#123; public static void f(int n)&#123; if(n&lt;0) return;//出口 f(n-1);//打印0 ~ n-1 System.out.println(n);//打印n &#125; public static void main(String[] args)&#123; f(9); &#125;&#125; 思路解释：“踢皮球”-常用来形容政府职能部门职责不清，相互推诿，比如你要到部门A盖个章，A叫你先去部门B盖章，B叫你去部门C盖章…这种将工作以踢皮球的方式甩给其他人做的方式其实很适用于递归。 但在递归中，如果你甩给其他人的工作和分配给你的工作完全一样，则程序陷入死循环，一直没有人进行工作，一直在甩锅，因此，递归中为：自己做一小部分事情，剩下的事情再甩给其他人去做。 我们要做的是打印除数字“0 - 9”，那么，我完全可以自己负责打印其中一个数（代码中表现为打印末尾数字9），将剩下的数字“0 - 8”交予其他人去打印，比如A打印9，B负责打印“0-8”，B又打印8,并将“0-7”甩给C去负责，C又打印7，剩下的甩给D…… 每次甩给下个人的工作都少了一点，在代码中表现为每次进行调用的参数都不一致，这就是发现逻辑“相似性”，每次调用的都是f(int n)这个方法，但每次参数都发生了变化，即f(n-1)。 但若一直递归下去，程序将陷入死循环，当n=0时，又会调用f(-1)，这显然不正确，因此，我们需要给递归加上一个出口限制，即if(n&lt;0) return;，当n&lt;0时，代表0~9都已经打印完毕，我们需要终止递归。 注：并不一定非得A打印9，将“0~8”甩给B…也可以A负责打印首位0，将“1~9”甩给B…这种情况有些许不一样（其实就是参数发生了变化）,代码如下： 12345public static void f2(int begin,int end)&#123; if(begin&gt;end) return; System.out.println(begin); f2(begin+1,end);&#125; 由上可看出，循环转递归，可能并非只有一种解法，也可存在多种改写形式，但都遵循“相似性”+“出口”的原则。 三.构造相似性 如果没有明显的相似性，需要主动构造 不能相似的原因很可能是缺少参数 递归与数学上的递推公式很类似 在循环转递归的过程中，可能并不具有非常明显的相似性，很可能是因为缺少参数的原因，这时候就需要我们去主动构造相似性，通常为增加参数来实现。 例子1： 1234567891011121314public class demo&#123; public static int addAll(int[] a)&#123; int x=0; for(int i=0;i&lt;a.length;i++)&#123; x+=a[i]; &#125; return x; &#125; public static void main(String[] args)&#123; int[] a=&#123;3,4,11,8&#125;; int sum=addAll(a); System.out.println(sum); &#125;&#125; 上述代码的功能为将数组a中的所有元素求和并打印。接下来，将循环改写为递归： 123456789101112public class Main&#123; public static int f(int[] a,int begin)&#123; if(begin==a.length) return 0;//出口 int x=f(a,begin+1); return x+a[begin]; &#125; public static void main(String[] args)&#123; int[] a=&#123;3,4,11,8&#125;; int sum=f(a,0); System.out.println(sum); &#125;&#125; 转为递归求和，我们一开始想到的肯定是定义一个求和方法，方法内传入要求和的数组，即 f(int[] a) ,但这样踢皮球每次甩给别人的都是原封不动的任务，导致程序进入死循环，因此我们需要加入一个参数 int begin 作为当前对象负责求和的起始元素的下标，这样，A只需要将 begin+1~end 的求和工作甩给B去做，B只需要再将拿到的begin进行+1操作,然后甩给C去做……待B传回求和的值，A再将B传回的值加上a[0]就可以得到数组所有元素之和了。 注：除了上述解法之外，还有以下解法： [0……end-1] ［end］，将数组拆成两部分，A负责end，将0~end-1甩给B去做； 折半求和： 12345678910111213141516public class Main&#123; public static int f(int[] a,int begin,int end)&#123; if(begin&gt;end) return 0; int middle = (begin+end)/2; //取中值 if(begin==end)&#123; return a[end]; &#125; return f(a,begin,middle)+f(a,middle+1,end); &#125; public static void main(String[] args)&#123; int[] a=&#123;3,4,11,8&#125;; int sum=f(a,0,a.length-1); System.out.println(sum); &#125;&#125; 例子2： 12345678public class demo&#123; public static boolean isSameString(String s1,String s2)&#123; return s1.equals(s2); &#125; public static void main(String[] args)&#123; System.out.println(isSameString("abc","abcd")); &#125;&#125; 上述代码的功能为比较两个字符串是否相同。接下来，将循环改写为递归： 1234567891011121314151617public class Main &#123; public static boolean f(String s1, String s2) &#123; if(s1.length()!=s2.length()) &#123; return false; &#125; if(s1.length()==0) &#123;//出口：当比较至两字符串为空时表示两字符串各字符均相同 return true; &#125; if(s1.charAt(0)!=s2.charAt(0)) &#123; return false; &#125; return f(s1.substring(1),s2.substring(1)); &#125; public static void main(String[] args) &#123; System.out.println(f("abc", "abcd")); &#125;&#125; 四.递归调用 递归调用仅仅是被调用函数恰为主调函数(自己调用自己) 注意每次调用的层次不同 注意每次分配形参并非同一个变量 注意返回的次序 如图所示：A运行到节点a，调用B，B运行到节点b，调用C，C执行结束之后，将结果返回节点b，B从节点b开始继续运行，B执行结束之后将结果返回节点a，A再从节点a开始继续运行… 该执行过程要求每一次节点中断调用其他方法，必须记录下该中断节点的环境信息，作用是为了调用结束返回结果之后原程序能够从上次中断位置起继续执行，在计算机中，通过一个栈结构来实现该效果(栈:先进后出)： A执行至a时将要去调用B，此时将节点a的环境信息通过压栈的方式保存在栈结构中，同理，在b节点处又将节点b的环境信息通过压栈的方式保存在栈结构中； 当C执行结束返回结果给B时，通过弹栈的方式将b进行出栈操作，这样B就可以从b开始继续运行，同理，当B执行完毕返回结果给A时，通过弹栈的方式将a进行出栈操作，这样A就可以从a开始继续运行。 逐层深入，逐层返回。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础学高数001：函数及其四种特性]]></title>
    <url>%2F2019%2F01%2F15%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%AB%98%E6%95%B0001%EF%BC%9A%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%9B%9B%E7%A7%8D%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[写在前面：从今天开始，开始准备考研数学之高等数学，受网上推荐基础薄弱适合看高昆轮老师的讲义视频，于是决定从高老师的视频讲义进入高数学习，将大一所学的高数知识捡起来，希望自己能够有所收获，也希望自己能够坚持到底，来年考上自己心仪的学校！ 函数的概念 注：定义域和对应法则是函数的两个基本要素，当且仅当两个函数的定义域以及对应法则都相同时，两个函数才是相同的。 函数的四种特性 有界性 单调性 理解单调不减和单调不增： 奇偶性 周期性]]></content>
      <categories>
        <category>数学</category>
        <category>考研</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>考研复习</tag>
        <tag>高昆轮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuilder、StringBuffer和String三者的联系和区别]]></title>
    <url>%2F2019%2F01%2F14%2FStringBuilder%E3%80%81StringBuffer%E5%92%8CString%E4%B8%89%E8%80%85%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.String类String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且大量浪费有限的内存空间。 12String a = "a"; //假设a指向地址0x0001 a = "b";//重新赋值后a指向地址0x0002，但0x0001地址中保存的"a"依旧存在，但已经不再是a所指向的,a 已经指向了其它地址。 因此String的操作都是改变赋值地址而不是改变值操作。 2.StringBuffer类StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量。 123StringBuffer buf=new StringBuffer(); //分配长16字节的字符缓冲区 StringBuffer buf=new StringBuffer(512); //分配长512字节的字符缓冲区 StringBuffer buf=new StringBuffer("this is a test")//在缓冲区中存放了字符串，并在后面预留了16字节的空缓冲区。 3.StringBuilder类StringBuilder和StringBuffer类功能基本相似，主要区别在于StringBuffer类的方法是多线程、安全的，而 StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。对于经常要改变值的字符串应该使用StringBuffer和StringBuilder类。 4.线程安全StringBuffer 线程安全StringBuilder 线程不安全 5.速度一般情况下,速度从快到慢:StringBuilder&gt;StringBuffer&gt;String,这种比较是相对的，不是绝对的。 6.总结 如果要操作少量的数据 用 String 单线程操作字符串缓冲区下操作大量数据 用 StringBuilder 多线程操作字符串缓冲区下操作大量数据 用 StringBuffer]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finally到底是在return之前执行还是return之后执行？]]></title>
    <url>%2F2019%2F01%2F11%2Ffinally%E5%88%B0%E5%BA%95%E6%98%AF%E5%9C%A8return%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E8%BF%98%E6%98%AFreturn%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[文章出自:WeChat公众号-程序员乔戈里 对话表情包出自:WeChat公众号-叔婆饭 “尊重原创” finally是在什么时候用呢？ finally一般是在try里面捕获异常用的，为了确保某些操作一定可以执行。 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; query(); &#125; public static void query() &#123; int i = 0; try &#123; i ++; i = i / 0;// 抛出异常 System.out.println("某一些操作"); &#125; catch (Exception e) &#123; i += 20; &#125; finally &#123; System.out.println("必需要执行的操作"); &#125; &#125;&#125; 执行结果： 1必需要执行的操作 比如说上面所示的代码，在try语句里面 i / 0 的话会抛出来异常，这样的话程序就在i / 0这里由于抛出了异常，所以程序不会继续往下去执行try包含的语句了。首先进入到catch语句里面，由于finally语句一定会执行，接下来就会执行finally中的语句，所以就得到了上面的执行结果。 比如我一些数据的关闭操作啦等，必须要执行的操作一定要放到finally语句，确保会执行。 finally语句一定会执行吗？ 一般来说，finally语句是一定会执行的 但有两种情况finally语句不执行: 在某些情况下，try语句压根就没有执行到，那么finally语句也一定就不会执行到了。 还有一种情况就是在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。 重头戏：finally是在retrun执行前执行还是在retrun执行后执行？ 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; int j = query(); System.out.println(j); &#125; public static int query() &#123; int i = 0; try &#123; System.out.print("try\n"); return i += 10; &#125; catch (Exception e) &#123; System.out.print("catch\n"); i += 20; &#125; finally &#123; System.out.print("finally-i:"+i + "\n"); i += 10; System.out.print("finally\n"); //return i; &#125; System.out.print("finish"); return 200; &#125;&#125; 执行结果： 1234tryfinally-i:10finally10 通过结果可以看得出来：只要try语句执行了以后，就算try语句里面有retrun语句，finally还是会执行。这就算所谓的finally一定会执行！ 那么？finally是在return执行后再执行咯？ 准确地说：finally是在return语句执行之后，return语句返回之前执行的！ 晕了~晕了~ 妈呀！这是啥意思？什么叫“是在return语句执行之后，return语句返回之前执行的”？ 前半句：在return语句执行之后 代码中try语句块中，return i+=10; 这个时候i已经是10了，这个可以从输出的打印结果看出来，因为进入到finally语句的时候，有一个打印语句，打印结果中i就是10，就说明了return语句中的i+=10是已经执行了。 后半句：在return语句返回之前 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; int j = query(); System.out.println(j); &#125; public static int query() &#123; int i = 0; try &#123; System.out.print("try\n"); return i += 10; &#125; catch (Exception e) &#123; System.out.print("catch\n"); i += 20; &#125; finally &#123; System.out.print("finally-i:"+i + "\n"); i += 10; System.out.print("finally\n"); return i; &#125; &#125;&#125; 执行结果： 1234tryfinally-i:10finally20 在JVM虚拟机种，有虚拟机栈，上面的代码中每一个方法都对应了一个栈帧，方法的执行对应的栈帧入栈，方法的执行完毕对应着栈帧的出栈。 栈帧可以理解为一个方法的运行空间。它主要由两部分构成，一部分是局部变量表，方法中定义的局部变量以及方法的参数就存放在这张表中；另一部分是操作数栈，用来存放操作数。 刚才的两段代码中的finally块中，i变量是要放到局部变量表的，每次有关于i的运算，都是要把i从局部变量表取出来（可以理解为copy一个副本），比如i += 10,那么需要把i和10都放到操作数栈中进行计算，然后得到一个结果，而这个结果是需要通过retrun语句写回到局部变量表。 第一段代码中的finally块中，虽然执行了i += 10,但是由于没有return，所以局部变量表中的内容没有变化，所以i还是10； 第二段代码中的finally块中，由于最后return i语句的执行，更新了局部变量中的i的值，所以最后返回的结果中i就是20了。 return返回后，就代表着方法执行结束，相应的该方法的栈帧就出栈了。而这个时候也就意味着，return返回是最后执行的，所以finally语句是在retrun返回之前执行的！ 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; cats = new ArrayList&lt;&gt;(); cats = query(cats); System.out.println("----"); for(String cat : cats) System.out.println(cat); &#125; public static List&lt;String&gt; query(List&lt;String&gt; cats) &#123; int i = 0; try &#123; System.out.print("try\n"); cats.add("xiaoMeng"); return cats; &#125; catch (Exception e) &#123; System.out.print("catch\n"); &#125; finally &#123; System.out.print("finally\n"); cats.add("qiaoGeLi"); &#125; System.out.println("finish"); return null; &#125;&#125; 若按照漫画中的结论，输出结果最终应该不会打印”qiaoGeLi”，而只打印”xiaoMeng” 但是，上述代码最终是会打印出来”xiaoMeng”和”qiaoGeLi”的！！！ 总结： finally是在retrun语句执行后，return返回之前执行的，也就是说finally必执行（当然是建立在try执行的基础上） finally中修改的基本类型没有return是不影响返回结果的，有了retrun才会影响 finally中修改list ,map,set引用类型时，就算没有return，也是是影响返回结果的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPT:拆拆拆！拆解文字！]]></title>
    <url>%2F2019%2F01%2F11%2FPPT%E6%8B%86%E6%8B%86%E6%8B%86%EF%BC%81%E6%8B%86%E8%A7%A3%E6%96%87%E5%AD%97%EF%BC%81%2F</url>
    <content type="text"><![CDATA[首先看一下上面这张图中国汉字一笔一划、一撇一捺，透漏出一股工整大气之美，但有时候，将 汉字进行拆解，往往会得出不一样的新奇效果。 PPT拆解汉字，接下来就是见证奇迹的时刻：步骤1：在PPT中输入文字 步骤2：在汉字下方画一个矩形，并将颜色设为黑色 步骤3：全选页面文字与矩形 步骤4：找到工具栏中的合并形状选择拆分（视版本而定，版本不同合并形状位置亦可能不同，2019版本位于绘图下的插入形状一栏中） 步骤5：然后取消全选，删去文字中被黑色覆盖的部分以及多余的黑色矩形 步骤6：将汉字各部分进行移动拆解 效果图：]]></content>
      <categories>
        <category>PPT小技巧</category>
      </categories>
      <tags>
        <tag>PPT</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是Markdown]]></title>
    <url>%2F2019%2F01%2F09%2F%E4%BB%80%E4%B9%88%E6%98%AFmarkdown%2F</url>
    <content type="text"><![CDATA[“We believe that writing is about content,about what you want to say-not about fancy formatting.” 我们坚信写作写的是内容，所思所想，而不是花样格式。 -Ulysses for Mac Word写作的痛苦像我们日常所使用到的文字编辑器例如word，在其工作界面提供了大量文字排版与字体设置的功能选项供我们选择（80%左右不会被使用到），像这种需要用户靠鼠标手动点击使用的文字软件称作富文本编辑器（耗时！耗力！反人类！）。富文本编辑器让我们浪费了大量的时间在文本排版上，是粗体or斜体，是宋体or黑体？？？然而，我们坚信写作写的是内容，所思所想，而不是花样格式。 相信每个人都经历过: Markdown定义Markdown 是一种轻量级标记语言，让写作者专注于写作而不用关注样式。优点众多，被越来越多的的写作人和撰稿者所使用。 虽说是一门标记语言，但markdown的语法相当简单，简单到每个人可在5分钟之内学会它！倘若你对前端编程知识有所了解，那么你完全可以将markdown视为一种简化版的HTML标记语言。 例如下图所示简单的markdown语法，将生成右图的页面效果： 图片来自花瓣网 Markdown写作的优点 从频繁的鼠标点击、排版设置中解放出来，专注于文字内容而非排版样式，安心写作。 轻松的导出HTML、PDF、word(配合插件使用)和本身的.md文件。 纯文本内容，兼容所有的文本编辑器与文字处理软件。 随时修改你的文章版本，不必像文字处理软件生成若干文件版本导致混乱。 可读、直观、学习成本低。 markdown支持的常用编辑器 在线 windows mac Github Typora Typora Stackedit MarkdownPad Mou 简书 MarkPad Macdown 博客园 Markdown Monster Ulysses CSDN Smark Miu ​ 本人选择了Typora，体验感jio良好(点击图片进入传送道) markdown语法(点击图片进入传送道)]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何通过学位服辨别学科]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%AD%A6%E5%A3%AB%E6%9C%8D%E8%BE%A8%E5%88%AB%E5%AD%A6%E7%A7%91%2F</url>
    <content type="text"><![CDATA[学位服，由学位帽、流苏、学位袍、垂布等四部分构成。 垂布，又称披肩，是由连颈帽演化而来。 一方面使学位服整体上富于变化，起到特有的装饰作用； 更重要的一方面，是通过垂布标识出所获学位的不同学科归属和授予学位的学校。 垂布按 文科 粉色 理科 灰色 医学 白色 农学 绿色 工学 黄色 军事 红色 图片来自花瓣网]]></content>
      <categories>
        <category>冷知识</category>
      </categories>
      <tags>
        <tag>冷知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中查找]]></title>
    <url>%2F2019%2F01%2F08%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[【问】：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。12345public class Solution &#123;public static boolean Find(int target, int[][] array) &#123; ... &#125;&#125; 两种解法： 思路1： 把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn 1234567891011121314151617181920212223public static boolean Find(int target, int[][] array) &#123; boolean flag = false; for (int i = 0; i &lt; array.length; i++) &#123; int low = 0, high = array[0].length - 1; if (flag) &#123; break; &#125; while (low &lt;= high) &#123; int mid = (low + high) / 2; if (target &gt; array[i][mid]) &#123; low = mid + 1; &#125; if (target &lt; array[i][mid]) &#123; high = mid - 1; &#125; if (target == array[i][mid]) &#123; flag = true; break; &#125; &#125; &#125; return flag; &#125; 思路2： 利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素num与target进行比较， 当target小于元素num时，那么target必定在元素a所在列的左边,即y- -； 当target大于元素num时，那么target必定在元素a所在行的下边,即x++； 1234567891011121314151617181920public static boolean Find(int target, int[][] array) &#123; int rowLen = array.length;// 行数 int x= 0;//位于第几行 int y = array[0].length;// 列数 &amp;&amp; 位于第几列 boolean flag = false; while (x &lt; rowLen &amp;&amp; y &gt;0) &#123; int num = array[x][y - 1]; if (target &lt; num) &#123; y--; &#125; if (target &gt; num) &#123; x++; &#125; if (target == num) &#123; flag = true; break; &#125; &#125; return flag; &#125;]]></content>
      <categories>
        <category>每日一道编程题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
</search>
